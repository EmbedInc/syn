<html lang="en-US">
<head>
  <link rel="stylesheet" href="document.css"></link>
  <title>SYN</title>
  </head>
<body>

<h1 class=page>Embed Syntaxer User's Guide</h1>
<p class=page>Last updated 12 Sep 2024</p>

<ul>
  <li><a href="#intro">Introduction</a><ul>
    <li><a href="#intro_usage">Usage overview</a>
    <li><a href="#intro_comp">Components</a>
    </ul>
  <li><a href="#source">Source Code</a><ul>
    <li><a href="#source_git">GIT repositories</a><ul>
      <li><a href="#source_git_build">Setting up source to be buildable</a>
      </ul>
    </ul>
  <li><a href="#instream">Input Stream</a><ul>
    </ul>
  <li><a href="#syn">Syntax Definition</a><ul>
    <li><a href="#syn_char">Character by character</a>
    <li><a href="#syn_constr">Syntax constructions</a>
    <li><a href="#syn_subrname">Subroutine names</a>
    <li><a href="#syn_ext">External parsing routines</a>
    <li><a href="#syn_padspace">PAD and SPACE constructions</a>
    <li><a href="#syn_tag">Tagging syntax items</a>
    </ul>
  <li><a href="#synlib">Using the SYN Library</a><ul>
    <li><a href="#synlib_doc">Documentation</a>
    <li><a href="#synlib_lib">Library management</a>
    <li><a href="#synlib_parse">Parsing the Input Stream</a>
    <li><a href="#synlib_tree">Traversing the Syntax Tree</a>
    </ul>
  <li><a href="#testsyn_cust">Modifying TEST_SYN for custom syntax</a><ul>
    </ul>
  <li><a href="#cust_constr">Manually creating syntax parsing routine</a><ul>
    </ul>
  <li><a href="#calc">CALC Example Application</a><ul>
    </ul>
  </ul>


<!-- -------------------------------------------------------------------------->
<h1 id="intro">Introduction</h1>

<p>The Embed Inc syntaxer is a library and programs to help software parse
and act on complex formal languages.  At a high level, the syntaxer
provides these services:<ol>

  <li>Validate an input stream as adhering to a syntax specification.

  <li>Discard the syntax details that are no longer relevant once the
  input stream is verified.

  <li>Identify and pass on only the parts of the validated input stream
  that must be acted upon, with syntax details stripped to the extent
  possible.

  </ol>

<h2 id="intro_usage">Usage overview</h2><indent>

  <p>The steps for the developer of an application to use the syntaxer are
  briefly listed here.  Subsequent sections of this document go into
  details.  At a high level, the steps for building an application to
  parse complex syntax with the Embed syntaxer are:<ol>

    <li>Define the syntax to parse using the SYN syntax definition
    language.  The SYN language is described in the <a
    href="../syn_file.txt">syn_file</a> documentation file.  This step
    amounts to writing a .syn file.

    <li>Compile the SYN file.  This is done with the Embed <a
    href="../../sst/sst.txt">SST</a> program, or the more specific <a
    href="../../sst/syn.txt">SYN</a> program.  The result of this step is
    C code that makes calls into the SYN library.  This code will parse
    the input stream and build the resulting syntax tree specific to the
    syntax definition it was compiled from.

    <li>Compile the C file from the previous step to a relocatable object
    file.  This object file will need to be linked with the application
    when that application is built.

    <li>Add calls to the application to use the SYN library to parse the
    input, build the syntax tree, then traverse that syntax tree and
    perform the specified actions.

    <li>When the application is built, the compiled object resulting from
    the SYN file must be linked to it.  The SYN library, and various
    additional Embed libraries used by SYN must also be statically linked
    to the application.

    </ol>

  </p></indent>

<h2 id="intro_comp">Components</h2><indent>

  <p>The overall syntaxer facility includes these software components:

  <h3>SYN library</h3><indent>

    <p>The SYN library is the run-time component of the syntaxer.  It must
    be linked to applications using the syntaxer.  Include files
    specifying the run-time interface are provided in C and Embed Pascal.
    The library provides procedural interfaces for:<ul>

      <li>Starting and ending independent uses of the SYN library.  The
      library supports multiple concurrent uses, each with its own state.

      <li>Parsing a collection of input lines according to a syntax
      definition, and building a syntax tree with the parts that are
      tagged in the syntax definition to pass on to the application.

      <li>Traversing the syntax tree, and retrieving the tagged items. The
      original input stream text for each syntax tree element can be
      identified and retrieved.

      <li>Emitting error, debug, and other messages related to syntax tree
      components, their location in the input stream, and appropriate
      snippets from that input stream.

      <li>Low level generic facilities used during parsing.  These are not
      usually accessed directly by the appliction.  They are called by the
      custom parsing code for a particular syntax.  This section of the
      SYN library provides the interface expected by the code compiled
      from the syntax definition file.

        <p>In special cases, the application may create specific syntax
        parsing routines "manually", by using these facilities directly
        instead of implicitly via the custom-compiled syntax parsing code.

      <li>Routines for parsing the SYN syntax definition language.  These
      are mostly derived from the <a href="../syn.syn">SYN.SYN</a> syntax
      definition file.  This file describes the SYN language syntax, using
      the SYN language.

      </ul>

    </p></indent>

  <h3>SST program</h3><indent>

    <p><a href="../../sst/sst.txt">SST</a> is the Embed source-to-source
    translator.  It is used to create C code from a syntax definition by
    using the SYN front end and C back end.

    </p></indent>

  <h3>SYN program</h3><indent>

    <p><a href="../../sst/syn.txt">SYN</a> is a custom version of SST that
    only compiles SYN files to C source.  It is less flexible than SST,
    but is all that is needed to create C source from syntax definition
    files.  SYN is intended for convenience when the full features of SST
    are not required.

    </p></indent>

  <h3>TEST_SYN program</h3><indent>

    <p><a href="../test_syn.txt">TEST_SYN</a> is a test program that shows
    the syntax tree resulting from a .syn file.  It can be useful to see
    the resulting syntax tree when writing a syntax definition.

    <p>The source code (<a href="../test_syn.pas">test_syn.pas</a>) also
    serves as a template for programs to provide the same function for
    other languages.  TEST_SYN always parses its input file according to
    the SYN language.  Only minor modifications are necessary to instead
    parse a different language specified by a different .syn file.
    Customizing TEST_SYN for a different language is detailed in a <a
    href="#testsyn_cust">later section</a> of this document.

    </p></indent>

  <h3>Other Embed libraries</h3><indent>

    <p>The SYN library is layered on other Embed libraries that must also
    be linked to the application.  These are SYS, UTIL, STRING, FILE, and
    FLINE.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="source">Source Code</h1>

<p>The syntaxer, as with most Embed software, is written in the Embed
Pascal language.  The details of this language are embodied in the
source-to-source translator (SST) program Pascal front end.  Pascal
modules are built by first translating them to C with SST, then compiling
the C code with commonly available compilers.

<p>Source code examples will be shown in the Embed Pascal language in this
document.  Readers generally familiar with Pascal or C should be able to
follow along.  It is not the purpose of this document to teach or explain
the Embed Pascal Language.

<h2 id="source_git">GIT repositories</h2><indent>

  <p>All source code for the syntaxer and components it relies on are open
  and available in GIT repositories on GitHub.

  <h3 id="source_git_build">Setting up source to be buildable</h3><indent>

    <p>This document assumes that the Embed full runtime sofware has been
    installed, local copies of the GIT source code repositories have been
    made, and the source can be built using the supplied build scripts.
    The Embed environment can be set up accordingly by going to the Embed
    <a href="http://www.embedinc.com/pic/dload.htm">software downloads
    page</a>, installing the full runtime environment, and following the
    directions to get the source code and set it up to be buildable.
    Tools for building Microchip PIC code need not be installed to use the
    syntaxer.

    <p>If the BUILD_HOST script runs without errors, then everything is
    set up properly.

    <p>Links in this document assume it is in the DOC directory in the SYN
    source repository, within the Embed SOURCE tree on the local machine.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="instream">Input Stream</h1>

<p>The input stream to be parsed by the syntaxer must be stored in memory.
Specifically, it must be in a collection of lines managed by the <a
href="../../fline/fline.ins.pas">FLINE</a> library.  This may seem
cumbersome at first, but it provides important advantages:<ol>

  <li>Allows going back and forth.  The syntaxer reads the input stream
  while following the syntax definition.  This may result in going down
  "dead ends" and backtracking where there are multiple possible syntax
  paths, until the path that matches the input is found.

    <p>Even if the syntaxer read an input stream "live", it would still
    need to store all that it read to be able to go back and take a
    different syntax branch from an earlier point.

  <li>Allows pointers to input stream sections.  Tagged sections of the
  input syntax are stored on the syntax tree.  Instead of making copies of
  the input stream sections, pointers are stored to the single copy of the
  input stream.

  <li>The application can manage getting the input stream.  There are many
  possible ways the input stream could be acquired beyond just reading it
  from a file.  It could be entered live by a user, the result of
  pre-processing a set of files, or generated entirely by the application.
  These possibilities should not be limited or dictated by the syntaxer.

  <li>Input files hierarchy is not lost.  The FLINE library allows for
  maintaining a flattened text stream that originated from a tree of input
  files, while still knowing what part of the original source each line
  was derived from.  This can be useful for emitting meaningful error
  messages to the user, for example.

    <p>A tree of files could be interpreted by a pre-processor, for
    example. Facilities in the FLINE library allow the pre-processor to
    indicate the location in the complete hierarchy of files that each
    output line results from.  Such a pre-processor is not limited to only
    expanding "include" directives.  There need not be a one-to-one
    correspondence of input lines to output lines.

    <p>The Embed pre-processor, <a
    href="../../escr/doc/index.htm">ESCR</a>, is an example of a
    pre-processor that can write its output to an FLINE source lines
    collection.

  <li>Each input file is only stored once.  If a tree of input files is
  flattened to create the syntaxer input stream, some low level input
  files may be referenced multiple times.  The FLINE library allows for
  storing each input file only once, but still maintaining the full
  hierarchy reference for each resulting output line.

  </ol>

<p>While the FLINE library allows for great flexibility, it also provides layered
routines for performing the simple cases simply.  For example, here is the entire code
from the TEST_SYN program that creates an FLINE collection of lines from the input
file:

<pre>
  fline_lib_new (                      {open the FLINE library}
    util_top_mem_context,              {parent memory context}
    fline_p,                           {returned pointer to new library use state}
    stat);
  sys_error_abort (stat, '', '', nil, 0);

  fline_file_get_suff (                {read the input file into a collection}
    fline_p^,                          {FLINE library use state}
    fnam_in, '.syn',                   {file name and mandatory suffix}
    coll_p,                            {returned pointer to the collection}
    stat);
  sys_error_abort (stat, '', '', nil, 0);
  </pre>

<p>The result of this code section is that <tt>coll_p</tt> is set pointing
to the input lines ready to pass to the syntaxer.

<p>The details of the FLINE library are beyond the scope of this document.
Since it is not relevant to the syntaxer how the input stream was acquired
or derived, examples in this document will assume the simplified case
where it is read directly from a single input file.


<!-- -------------------------------------------------------------------------->
<h1 id="syn">Syntax Definition</h1>

<p>The syntax that the syntaxer is customized to parse in any one instance
is defined by a syntax definition file.  The name of this file always ends
in ".syn".  This SYN file ultimately results in executable code specific
to the particular syntax.  This code is then linked with the application
and the SYN library.

<p>The SYN file is therefore only used in building the application.  It is
not read at run time.  If the syntax is changed, the SYN file must be
changed accordingly and the application re-built for the change to take
effect.

<p>The SYN file language is described in the <a
href="../syn_file.txt">syn_file</a> documentation file.  The remainder of
this document assumes the reader understands the syntax definition
language.

<h2 id="syn_char">Character by character</h2><indent>

  <p>Unlike some other syntax parsing systems, the input stream is not
  "tokenized" or otherwise processed in multiple stages.  At run time, the
  syntaxer matches the input stream to the syntax definition character by
  character.  If there needs to be a space or new line at some point, for
  example, then that must be explicitly stated in the syntax definition.

  <p>In this sense, the syntaxer is "dumb".  It simply compares the
  current input character to the current point in the syntax definition.
  If they match, then it continues to the next character.  If they do not
  match, then it pops back to the last decision point (in both the syntax
  definition and the input stream) and tries the next possible syntax
  branch.

  <p>If no branches thru the syntax possiblities match the input stream,
  then there is a syntax error.  The syntaxer saves the furthest point in
  the input stream that did match the syntax, and indicates error at the
  next character.  The application can get this location in the input
  stream.  It can also traverse the partial syntax tree to the error
  point, which may provide some semantic context for the error.

  </p></indent>

<h2 id="syn_constr">Syntax constructions</h2><indent>

  <p>A particular syntax is defined by a nested series of syntax
  constructions.  Each named symbol in the SYN file is one construction. A
  construction results in one syntax parsing subroutine in the compiled
  syntax code, and a separate subordinate level in the syntax tree after
  parsing.

  <p>Within a construction, syntax is defined as a sequence of "items"
  called an "expression".  Items are those built into the syntax
  definition language, or subordinate constructions specified by the
  construction name.  An expression in parenthesis becomes a single item.
  This allows expressions to be nested.

  <p>There is no fixed rule as to how the overall syntax should be broken
  into separate constructions.  Deciding what to include in-line in an
  existing construction versus creating a subordinate construction is much
  like deciding what to put in a single routine versus breaking it into
  multiple subordinate subroutines.  However, the following should be kept
  in mind:<ul>

    <li>Each construction creates its own nested level in the syntax tree.

    <li>The name of the construction for a particular syntax tree level
    can be determined by the application when traversing the syntax tree.
    This can aid in debugging and in providing more useful information for
    error messages.  Note that the TEST_SYN program shows the construction
    name at the start of each syntax tree level.

    <li>The current nested list of construction names is maintained as the
    input stream is parsed.  This hierarchy can be shown to the user for
    debugging purposes and in error messages.

    </ul>

  <p>In general, it is good to create a separate construction for any
  recurring syntax.  For example, consider the INTEGER construction of the
  SYN language:</p><indent>

<pre>
.define INTEGER .as
  .occurs [1 to INF] .range ['0' thru '9']
</pre></indent>

  <p>This is a simple integer, comprised of one or more sequential decimal
  digits.  The INTEGER construction is then used in several places in the
  SYN definition.

  <p>It can also be useful to have the application code that processes the
  syntax tree have a separate subroutine for each construction.

  <p>In this example, it would make sense to have a separate subroutine to
  get an integer value.  The subroutine expects to be in the parent syntax
  level, with the next entry being the subordinate INTEGER level.  The
  subroutine goes down into the subordinate level, gets the digit
  characters, interprets them into an integer value, and pops back up to
  the parent level while returning the integer value.  In the parent
  routine, the subortinate INTEGER is treated like a single entity.

  <p>Consideration should therefore be given to how the syntax tree
  traversing code will be structured when deciding how to break up a
  syntax into nested constructions.

  </p></indent>

<h2 id="syn_subrname">Subroutine names</h2><indent>

  <p>As stated before, each syntax construction in the SYN file results in
  a separate parsing subroutine.  By default, these subroutine names are
  automatically generated.  Applications do not need to know the names of
  most syntax parsing routines because they will only be called from other
  syntax parsing routines.

  <p>However, at least the top level parsing routine must be known to the
  application, since the application must supply a pointer to the routine
  to start parsing.  For this reason, a fixed subroutine name can be
  specified in the .SYMBOL command for the construction.

  <p>In general, it is recommended that only those parsing routines
  referenced directly by the application be named, and that the names be
  SYN_CH_xxx.  Names starting with SYN_CH_ are reserved for parsing
  routines and are not used in the SYN library.

  <p>In this respect, do not use the SYN syntax definition as a guide. All
  routines were explicitly named to avoid name collisions with
  user-generated parsing routines since the SYN parsing routines are
  always part of the SYN library.  The SYN parsing routines are named
  SYN_CHSYN_xxx, where XXX is the construction name.  Nothing else in the
  SYN library is named starting with SYN_CHSYN_, so these routines are
  effectively in their own namespace.

  </p></indent>

<h2 id="syn_ext">External parsing routines</h2><indent>

  <p>SYN constructions provide a compact and reasonably user-friendly
  means to describe the actions of syntax parsing routines.  The actual
  code generated by the SYN program is much more verbose, harder to
  understand, and harder to modify.  Fortunately this complexity and
  obfuscation is largely irrelevant since these routines are written by
  machine.

  <p>However, there is no requirement that syntax parsing routines
  <i>must</i> only be generated by the SYN compiler.  The interface used
  by the parsing routines is documented and exported by the SYN library.
  These are routines with names SYN_P_xxx.

  <p>It is possible to manually write a parsing routine by using the same
  interface as SYN-generated parsing routines.  This can allow for
  features not available via the SYN language, or to perform other
  application-specific actions during parsing.

  <p>Writing your own syntax parsing routine is an advanced concept
  covered in a <a href="#cust_constr">later section</a> of this document.

  <p>The SYN language provides a means to indicate a syntax construction
  is not defined in the SYN file, and that its parsing routine is
  implimented externally to the automatically-generated parsing routines.
  This mechanism is the optional EXTERN keyword in the .SYMBOL command.
  When the contruction is declared EXTERN, then its subroutine name must
  be explicitly given.  The externally defined construction can then be
  used like any other syntax construction in the remainder of the SYN
  file.

  </p></indent>

<h2 id="syn_padspace">PAD and SPACE constructions</h2><indent>

  <p>As mentioned before, there is no separate tokanizer or other
  pre-parsing pass over the input stream.  Not all syntaxes can be
  described as a sequence of tokens, and there is never a need to specify
  them that way.

  <p>However, allowing or requiring one or more spaces between syntax
  items is common to many languages, including the SYN language.  These
  functions are implemented with the PAD and SPACE constructions in the
  SYN language definition.

  <p>The SYN language is comprised of flowed text, meaning that end of
  line is a separator like space.  This also means that indentation per
  line is irrelevant.

  <p>The PAD construction allows for any number of separators.  These are
  space, end of line, and end of nested file.  End of line comments are
  also automatically skipped over.

  <p>SPACE is the same thing except that at least one separator is
  required.

  <p>As mentioned in the <a href="#syn_subrname"><i>Subroutine
  names</i></a> section (above), all the SYN language parsing routines are
  part of the SYN library with fixed names.  The PAD and SPACE parsing
  routines are therefore always available, with names
  <tt>syn_chsyn_pad</tt> and <tt>syn_chsyn_space</tt>, respectively. These
  two syntax parsing routines were written manually to exploit efficiency
  made possible by special characteristics of these constructions.  There
  is more detail on this in a later section about <a
  href="#cust_constr">writing your own syntax parsing routines
  directly</a>.

  <p>If the SYN PAD and SPACE constructions happen to match the
  requirements of a custom syntax, then they can be used directly.  To do
  that, declare the constructions EXTERN, and provide the routine names
  given above.  Note that the constructions do not need to be called "PAD"
  and "SPACE", but the routine names must be referenced verbatim.

  </p></indent>

<h2 id="syn_tag">Tagging syntax items</h2><indent>

  <p>One of the powerful features of the syntaxer is that it only passes
  on to applications those parts of the input stream that are relevant
  after all the syntax details have been verified.  For example, consider
  the simple Pascal assignment statement:

  <pre>
    <i>variable</i> := <i>expression</i>;
    </pre>

  <p>After all the syntax details have been checked, the application only
  needs to act on the variable name and the expression string.  The ":="
  assignment operator and ending ";" no longer matter after they have been
  verified.  The syntaxer would also probably verify that the variable
  name contained only certain characters, and didn't include a space.
  There would also likely be basic syntactical validation of the
  expression.

  <p>Passing on only selected parts of the parsed input for semantic
  processing is done by "tagging" those parts of the input.  In this
  example, the variable name and expression would be tagged.  Tagging is
  done by appending a number in brackets immediately after the syntax item
  being tagged in the syntax definition.  This number must be a simple
  decimal integer of 1 or greater.

  <p>For example, here is a possible assignment statement syntax
  definition:

  <pre>
  .define assignment .as
    variable[1] pad ":=" pad expression[1] pad ";"
  </pre>

  <p>In this example, the PAD construction allows for zero or more
  separators, like blanks and new lines.  VARIABLE and EXPRESSION are
  syntax constructions defined separately.

  <p>When an assignment statement is parsed, only links to the variable
  name and the expression string are added to the syntax tree.  In this
  case, both are tagged with the ID of 1.  The ID values in this case are
  arbitrary since they are not necessary for determining which syntax path
  was taken.  Once in the ASSIGNMENT syntax tree level, there are always
  two tagged items.  These are the variable name and the expression string
  in that order.

  <p>When the application traverses the syntax tree and finds an
  assignment statement, it first goes down into the subordinate assignment
  statement tree level. There it gets the string for the first tag and
  interprets it as the variable name.  It gets the second tag and
  interprets it as an expression.  Note that the ":=" assignment operator,
  the ending ";", and possible intersperced blanks and new lines are not
  considered at this point.  This syntax tree content wouldn't be here if
  those syntax details weren't correct.

  <p>In some cases, the tag IDs are used to indicate which syntax branch
  was taken.  To continue with our Pascal statement example, an excutable
  statement definition could be:

  <pre>
  .define exec_statment .as
    .
    .
    .
    assignment[5] .or
    subroutine_call[6] .or
    for_loop[7] .or
    .
    .
    .
    </pre>

  <p>In this case, the statement only matches one of the syntax choices.
  If it is an assignment statement, the next syntax tree item will be tag
  5, if a subroutine call tag 6, etc.  In this case it is up to the SYN
  file writer to ensure that the tags for each choice are unique.

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="synlib">Using the SYN library</h1>

<p>This section describes how to use the SYN library from the
application's point of view.  The application-visible interface to the SYN
library is defined in the syn.ins.pas include file (and syn.h, which is
derived from syn.ins.pas).  It may be helpful to refer to the include file
while reading this section.


<h2 id="synlib_doc">Documentation</h2><indent>

  <p>Information about using the SYN library is in several different
  places:

  <h3>SYN.HTM (this file)</h3><indent>

    <p>The file you are reading now (SYN.HTM in the SYN repository DOC
    subdirectory) is intended to be the first level of documentation.  It
    provides an introduction, overview, and then details of using the SYN
    library.  This file is intended to be read before writing any
    application code.

    </p></indent>

  <h3>SYN.INS.PAS comments</h3><indent>

    <p>The comments in the Pascal include file (syn.ins.pas) provide quick
    reminders about the various routines, arguments, and data structures.
    It is intended to be referred to continually when writing application
    code, once a basic understanding of the library has been achieved.

    </p></indent>

  <h3>Source code header comments</h3><indent>

    <p>Each routine is described in more detail in its header comments
    immediately above the source code implementing that routine.  These
    comments are meant to provide the definitive details for using each
    routine.

    <p>Routines are grouped by function using a naming hierarchy. The
    names of all public symbols in the SYN library start with "syn_". Each
    successive "word" in the names provides more detail, until eventually
    the name becomes unique.  For example, the library managenment routine
    names start with "syn_lib_", and the routines for traversing a syntax
    tree "syn_trav_".

    <p>Routines are usually grouped into source files by this same naming
    hierarchy.  The "syn_lib_" routines are in the "syn_lib.pas" file, and
    the syntax tree traversing routines in the "syn_trav.pas" file, for
    example.  Particularly large or complex routines may be in their own
    files with more specific names.  While this file naming scheme is
    generally followed, there may be exceptions.  A pattern search over
    the "syn_*.pas" files may need to be performed to find the source code
    of a particular routine.

    <p>It is intended that the header comments in the source code of
    particular routines will be occasionally referenced when writing
    application code.

    </p></indent>

  <h3>Source code</h3><indent>

    <p>If all else fails, read the source code.  This is not intended to
    be necessary, but all the other documentation is never going to be
    perfect.  The source code is written such that the logic flow can be
    followed by largely reading the comments, but again, nothing is
    perfect.

    </p></indent>

  </p></indent>


<h2 id="synlib_lib">Library management</h2><indent>

  <p>The state for each use of the SYN library is kept in a <tt>syn_t</tt>
  data structure.  This data is dynamically allocated when a new use of
  the SYN library is started, and released when that library use is ended.
  The application must keep a pointer to the SYN library use state, and
  pass the use state when calling SYN library routines.

  <p>The routines for library management are:</p><indent>

<p><pre>
procedure syn_lib_new (                {create new use of the SYN library}
  in out  mem: util_mem_context_t;     {parent mem context, will create subordinate}
  out     syn_p: syn_p_t);             {pointer to new SYN library use state}
  val_param; extern;

procedure syn_lib_end (                {end a use of the SYN library}
  in out  syn_p: syn_p_t);             {pointer to lib use state, returned NIL}
  val_param; extern;
</pre></p></indent>

  <p>The first routine allocates and initializes a new library use state,
  and passes back <tt>syn_p</tt> pointing to it.

  <p>The Embed tree-structured dynamic memory facility is used.  Dynamic
  memory is always allocated under a "memory context".  These contexts can
  be tree structured.  Deleting a memory context automatically deletes any
  subordinate contexts, and deallocates all dynamic memory allocated to
  those subordinate contexts.  The tree-structured dynamic memory routines
  are in the UTIL library.

  <p>A private memory context is always created for each SYN library use.
  All dynamic memory allocated by a library use is therefore automatically
  deallocated when that library use is ended.

  <p>Applications can create their own dynamic memory context that a SYN
  library use will be subordinate too.  If this is not needed, the top
  level (root) memory context can be used as the parent for the private
  SYN library memory context.  This top memory context is called
  <tt>util_top_mem_context</tt>.

  <p>For example, the TEST_SYN program uses the top memory context for the
  parent:</p><indent>

<p><pre>
  syn_lib_new (                        {open the SYN library}
    util_top_mem_context,              {parent memory context}
    syn_p);                            {returned pointer to new library use state}
</pre></p></indent>

  <p>Subsequent SYN routines are passed the SYN library use state by
  reference.  Note that in Pascal this is done by passing the use state
  directly (not a pointer to it) with <tt>syn_p^</tt>.  However, since
  this argument is declared <tt>in out</tt> in each routine template, the
  compiler actually passes a pointer to the use state.

  <p>Ending a use of the SYN library is very simple.  From TEST_SYN:</p><indent>

<p><pre>
  syn_lib_end (syn_p);                 {end this use of the SYN library}
</pre></p></indent>

  <p>Unlike the normal "working" routines of the SYN library,
  <tt>syn_lib_end</tt> is explicitly passed a pointer to the use state.
  Since this routine ends a library use and deallocates all its dynamic
  memory, including the use state, the pointer is returned NIL.

  </p></indent>

<h2 id="synlib_parse">Parsing the input stream</h2><indent>

  <p>Once a SYN library use has been created, the next step is to parse
  the input stream.  While the documentation refers to the input "stream",
  it is actually a collection of source lines managed by the FLINE
  library.  See the TEST_SYN program for an example of reading the
  contents of a file into an FLINE library collection of lines.

  <p>Parsing is done in two steps.  First the current position within the
  input stream is set, then a parse initiated from that position.

  <p>The current input stream position can be set to the start of a
  collection of lines with:

</p><indent><p><pre>
procedure syn_parse_pos_coll (         {set parse position to start of collection}
  in out  syn: syn_t;                  {SYN library use state}
  in var  coll: fline_coll_t);         {collection to go to start of}
  val_param; extern;
</pre></p></indent>

  <p>Parsing from the current position is initiated with:

</p><indent><p><pre>
function syn_parse_next (              {parse, continue from current position}
  in out  syn: syn_t;                  {SYN library use state}
  in      syfunc_p: syn_parsefunc_p_t) {top level syntax to parse against}
  :boolean;                            {no error, syntax tree built}
  val_param; extern;
</pre></p></indent>

  <p>The function returns TRUE if parsing was successful and a syntax tree
  built, or FALSE if a syntax error was encountered.  In the latter case,
  no syntax tree is built.  There is more on handling syntax errors below.

  <p>If parsing from the start of a collection of lines, then the
  convenience routine

</p><indent><p><pre>
function syn_parse_coll (              {parse from start of collection of lines}
  in out  syn: syn_t;                  {SYN library use state}
  in var  coll: fline_coll_t;          {collection of input lines to parse}
  in      syfunc_p: syn_parsefunc_p_t) {top level syntax to parse against}
  :boolean;                            {no error, syntax tree built}
  val_param; extern;
</pre></p></indent>

  <p>can be used.  This combines <tt>syn_parse_pos_col</tt> and
  <tt>syn_parse_next</tt> into a single call.

  <p>Note that a pointer to the top level syntax construction is passed to
  <tt>syn_parse_next</tt>.  This is how the code resulting from compiling
  the .SYN syntax definition file is invoked.  This also means that at
  least the top level syntax construction must be given an explicit name
  in the .SYN file.

  <p>For example, the top level syntax construction of the SYN language is
  <tt>command</tt>.  This syntax construction symbol is therefore given an
  explicit subroutine name in SYN.SYN:

</p><indent><p><pre>
.symbol command[syn_chsyn_command]
</pre></p></indent>

  <p>A pointer to this subroutine is then passed to
  <tt>syn_parse_next</tt> in TEST_SYN to initiate parsing of the next
  command:

</p><indent><p><pre>
  match := syn_parse_next (            {parse from the current position}
    syn_p^,                            {SYN library use state}
    addr(syn_chsyn_command));          {top level syntax construction to parse}
</pre></p></indent>

  <p>In this case, <tt>match</tt> is a boolean variable that will indicate
  whether the input stream matched the syntax definition.  Successful
  parses and parses that encountered a syntax error must be handled
  differently.

  <h3>After successful parse</h3><indent>

    <p>When <tt>syn_parse_next</tt> returns TRUE, the input stream matched
    the syntax definition, and a syntax tree was built.  The application
    would then usually proceed to traversing the syntax tree.  See <a
    href="#synlib_tree"> <i>Traversing the Syntax Tree</i></a>, below.

    </p></indent>

  <h3>After syntax error</h3><indent>

    <p>When <tt>syn_parse_next</tt> returns FALSE, the input stream did
    not match any path thru the syntax definition.  This means there is a
    syntax error in the input stream.

    <p>Because of how the parser works, only an empty syntax tree results
    from a syntax error.  The parser matches the input stream against the
    syntax definition.  When a choice is encountered in the syntax
    definition, the parser saves the location of both the input stream and
    the syntax definition at that point.  If subsequent parsing does not
    match the syntax branch taken, state is restored to the decision point
    and the next syntax branch tried.

    <p>When there is a syntax error, there is no valid path thru the
    syntax definition, so eventually state is restored to the starting
    point.  When there are no more syntax choices to test, then the parse
    is aborted and <tt>syn_parse_next</tt> returns FALSE.

    <p>Some of the syntax branches might be more "right" than others, but
    the parser can not determine that since they are all ultimately wrong.
    To allow getting more information about a syntax error, the first
    input stream position that did not match any syntax branch is saved.
    This position can be retrieved with:

</p><indent><p><pre>
procedure syn_parse_err_pos (          {get the position of error after failed parse}
  in out  syn: syn_t;                  {SYN library use state}
  out     epos: fline_cpos_t);         {position of first char not to match syntax}
  val_param; extern;
</pre></p></indent>

    <p>The application can find the original source file, line number,
    character position, line contents, and other information from the
    returned error position.  This can be useful, for example, in emitting
    a meaningful error message to the user.  If this is the intent, the
    convenience routine

</p><indent><p><pre>
procedure syn_parse_err_show (         {show error position after failed parse}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

    <p>can be used.  This shows the input file hierarchy at the error
    position, the line containing the error, and the offending character.

    <h4>Error re-parse</h4><indent>

      <p>If only some or one syntax path reached the syntax error
      position, then more context can be provided for the syntax error.
      For example, consider the invalid Pascal assignment statement:

</p><indent><p><pre>
  ii := ++$^;
</pre></p></indent>

      <p>The syntax is valid past the ":=" indicating an assignment
      statement.  This additional information can be useful in emitting a
      more helpful error message to the user.  Instead of merely pointing
      to the second "+" as a syntax error, the error message could
      indicate "Invalid expression in assignment statement", for example.

      <p>To get this additional context, the parse can be re-done, but
      stop with a partially-built syntax tree when the error position is
      reached.  This is done by performing an error re-parse:

</p><indent><p><pre>
procedure syn_parse_err_reparse (      {reparse after error, builds tree up to err}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

      <p>This routine must only be called with the state left after a
      parse that resulted in a syntax error.  The syntax tree of the first
      path thru the input stream that matched everything up to the error
      position will result.  The application can then traverse the partial
      syntax tree to get more information about what was expected at that
      point.

      <p>Note that emitting a pure syntax error message with the error
      position can still be useful, even if followed up by a more
      context-specific error message.

      </p></indent>

    </p></indent>

  <h3>Continuing to next parse</h3><indent>

    <p>Depending on the syntax definition, each parse may only consume
    part of the input stream.  This is the case, for example, with the SYN
    syntax definition.  One <tt>command</tt> construction is parsed and
    handled at a time, with the input stream containing successive
    <tt>command</tt> constructions.

    <p>A successful parse leaves the input stream position after the
    last-consumed input character.  Therefore <tt>syn_parse_next</tt> can
    be called after done with the result of the previous parse.  This is
    in fact what TEST_SYN does.

    <p>The input stream will of course end at some point.  This could be
    handled by specifying the <tt>.eod</tt> (end of data) item in the
    syntax definition with a unique tag.  However, it is often convenient
    for the application to check whether the whole input stream has been
    consumed.  This can be done with:

</p><indent><p><pre>
function syn_parse_end (               {check for at end of input}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {parse position is after all data}
  val_param; extern;
</pre></p></indent>

    <p>The function returns TRUE if the parse position is after all data,
    and FALSE otherwise.

    </p></indent>

  </p></indent>

<h2 id="synlib_tree">Traversing the Syntax Tree</h2><indent>

  <p>A syntax tree is left after a successful parse or an error re-parse.
  The syntax tree contains a sequence of entries in a tree structure.
  These entries are either parts of the input stream deliberately tagged
  by the syntax definition, or used to define the tree structure.

  <p>Each level in the syntax tree has an entry that indicates its start
  and end.  A level can also contain entries that point to subordinate
  syntax tree levels.  Each of those has a start and end, and can point to
  lower syntax tree levels, etc.

  <p>The special error-end entry only exists in a tree resulting from an
  error re-parse.  It can occur at any level, and marks the farthest point
  in the input stream that matched the syntax definition.

  <p>All syntax tree traversal actions are performed by calling SYN
  library routines with names SYN_TRAV_xxx.

  <h3>Traversal overview</h3><indent>

    <p>The SYN library maintains a current position within the syntax
    tree.  The application traverses the tree by advancing to the next
    entry.  If that entry is a subordinate level, then the application can
    go down into the subordinate level.  The application can pop back to
    the parent level at any time, although this is usually done with the
    end of the subordinate level is encountered.

    <p>Named syntax constructions in the syntax definition result in
    subordinate syntax tree entries.  Tagged items in the syntax
    definition result in "tag" entries in the current level.  Applications
    can determine and retrieve the input stream characters that were
    tagged.  Acting upon tagged entries is how the application implements
    whatever semantics were specified by the input stream.

    </p></indent>

  <h3>Initializing</h3><indent>

    <p>After a parse, the syntax tree traversal state must be initialized
    before the tree can be traversed.  This is done with:

</p><indent><p><pre>
procedure syn_trav_init (              {init traversion, at start, stack empty}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

    <p>This sets the current traversal position to the start of the tree,
    which is the start of the top level.  The current entry will be the
    start of the top tree level.

    <p>The syntax tree position stack is also initialized to empty.  The
    position stack is discussed in more detail in the section
    <i>Saving/restoring tree position</i>, below.

    </p></indent>

  <h3>Getting entries</h3><indent>

    <p>There are two types of values used to indicate what an entry is.
    These are a <tt>syn_tent_k_t</tt> enumerated value, and an ordinary
    integer.

    <p>The enumerated value is useful for determining the overall type of
    a syntax tree entry, while maintaining strong type checking.  The
    possible values are:</p><indent><dl>

      <dt><tt>syn_tent_lev_k</tt><dd>

        <p>First entry of a syntax tree level.  All syntax tree levels
        start with this entry.

      <dt><tt>syn_tent_end_k</tt><dd>

        <p>Last entry of a syntax tree level.  There is no "next" entry
        here. Attempts to get subsequent entries at this level result in
        staying at this END entry.

      <dt><tt>syn_tent_sub_k</tt><dd>

        <p>A subordinate level exists below this entry.

      <dt><tt>syn_tent_tag_k</tt><dd>

        <p>Result of a tag in the syntax definition.

      <dt><tt>syn_tent_err_k</tt><dd>

        <p>The farthest point reached in the input stream during an error
        re-parse.  There is no "next" entry.

      </dl></p></indent>

    <p>The integer value is the only way to get the ID of a tag in the
    syntax definition.  Tag IDs are always integers of 1 or greater.
    Non-tag tree entries are indicated with 0 or less.  These are one of
    the constants SYN_TAG_xxx_K.

    <p>The current entry can be determined by calling one of

</p><indent><p><pre>
function syn_trav_type (               {get type of current syntax tree entry}
  in out  syn: syn_t)                  {SYN library use state}
  :syn_tent_k_t;                       {syntax tree entry type ID}
  val_param; extern;

function syn_trav_tag (                {get ID of current tag entry}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {1-N tag number or SYN_TAG_xxx_K}
  val_param; extern;
</pre></p></indent>

    <p>The first gets the enumerated entry type ID, and the second the
    integer entry ID value.

    <p>To advance to the next sequential entry in the current tree level,
    call one of:

</p><indent><p><pre>
function syn_trav_next (               {to next syntax tree entry}
  in out  syn: syn_t)                  {SYN library use state}
  :syn_tent_k_t;                       {type of syntax tree entry found}
  val_param; extern;

function syn_trav_next_tag (           {to next entry, return its tag value}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {1-N tag number or SYN_TAG_xxx_K}
  val_param; extern;
</pre></p></indent>

    <p>As before, the first returns the entry type ID of the new entry,
    and the second its integer ID value.

    <p>Two functions can be used to go down into a subordinate syntax tree
    level:

</p><indent><p><pre>
function syn_trav_down (               {down into subordinate level from curr entry}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {successfully entered subordinate level}
  val_param; extern;

function syn_trav_next_down (          {into sub level of next entry}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {next was sub level, moved down}
  val_param; extern;
</pre></p></indent>

    <p>The first goes down from the current entry.  The second first
    advances to the next entry in the current level, then attempts to go
    down into a subordinate level from there.  In either case, the
    function returns TRUE if the tree position is now one level lower than
    when the call was made.  FALSE indicates that the entry attempting to
    go down from was not a subordinate level entry.

    <p>To go back up from a subordinate level to the parent level, use:

</p><indent><p><pre>
function syn_trav_up (                 {pop up to parent syntax tree level}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {successfully popped to parent level}
  val_param; extern;
</pre></p></indent>

    <p>When successful (there was a parent level), the current entry is
    the one immediately after the subordinate level entry in the parent.

    </p></indent>

  <h3>Getting input stream text</h3><indent>

    <p>The purpose of navigating syntax is ultimately to determine the
    content of text in a particular formal language.  Tags are how content
    snippets are conveyed to applications using the syntaxer.

    <p>As descripbed earlier, sections of the input stream are "tagged" in
    the syntax language definion with integer values of 1 or higher.  This
    is done by following a syntax item with the integer value in square
    brackets.

    <p>For example, the DECLARE command of the SYN language is defined
    using three tags:

</p><indent><p><pre>
.define DECLARE .as
  '.symbol' space
  symbol[1] pad
  .optional (
    '[' symbol[1] ']'
    .optional (space 'external'[2])
    )
</pre></p></indent>

    <p>This definition says that the DECLARE syntax construction starts
    with the keyword ".symbol", followed by a space, followed by the
    "symbol" syntax construction.

    <p>The ".symbol" keyword and space are no longer needed once it is
    determined the input string matches the DECLARE construction.  These
    items are only for determining the right path thru the syntax
    definition during parsing.  There is nothing further the application
    needs to know about these while traversing the syntax tree.

    <p>However, the name of the symbol being declared is something the
    application does need to handle.  This is why it was tagged.  Only
    tagged items are linked to from the syntax tree.

    <p>There are two SYN library routines that the application can call to
    get more information about a tagged item on the syntax tree:

</p><indent><p><pre>
procedure syn_trav_tag_start (         {get start loc for tag at curr tree entry}
  in out  syn: syn_t;                  {SYN library use state}
  out     pos: fline_cpos_t);          {start of tagged string in source lines}
  val_param; extern;

procedure syn_trav_tag_string (        {get string tagged by current tree entry}
  in out  syn: syn_t;                  {SYN library use state}
  in out  tagstr: univ string_var_arg_t); {returned tagged string}
  val_param; extern;
</pre></p></indent>

    <p>The first gets the starting position of the tagged item in the
    input stream. Remember that the whole input stream remains in memory
    until explicitly released.  The returned POS value can be used to get
    detailed information on the input stream position from the FLINE
    library.  This information includes the exact line and column numbers,
    and nested file hierarchy.  Details of how to use the FLINE library
    are beyond the scope of this document.

    <p>The second routine is a simple way to get a copy the input stream
    characters that were tagged.  In the example above, this would be the
    bare symbol name, with all surrounding syntax stripped.

    <p>Note that the tag number is not really needed in the this example.
    The only possible path thru the DECLARE construction includes the
    symbol name as the first tagged item.

    <p>The remainder of the DECLARE syntax after the name of the symbol
    being defined can either be nothing, or another symbol name in literal
    brackets optionally followed by the "external" keyword.  The
    application must check for tag entries on the syntax tree to determine
    which syntax path was taken.

    <p>If there is a second tag, then that tag is for another symbol name.
    If there is a third tag, then the "external" keyword was used.  In the
    case of the third tag, just the existance or non-existance of the tag
    indicates the choice.  There is no need to fetch the string for the
    third tag, since it will always be "external".

    </p></indent>

  <h3>Saving/restoring tree position</h3><indent>

    <p>It can be useful for applications traversing the syntax tree to
    save positions on that tree, and later return to them.  There are two
    mechanisms provided for this purpose.

    <h4>Explicit position</h4><indent>

      <p>The current syntax tree position can be saved and restored
      explicitly with these routines:

</p><indent><p><pre>
procedure syn_trav_save (              {save current syntax tree position}
  in out  syn: syn_t;                  {SYN library use state}
  out     pos: syn_treepos_t);         {returned syntax tree position}
  val_param; extern;

procedure syn_trav_goto (              {go to previously-saved syn tree position}
  in out  syn: syn_t;                  {SYN library use state}
  in      pos: syn_treepos_t);         {saved position to go to}
  val_param; extern;
</pre></p></indent>

      <p>The first saves the current position, and the second jumps back
      to that position.  In this case, the application must maintain a
      SYN_TREEPOS_T structure for each saved position.

      </p></indent>

    <h4>Stacked position</h4><indent>

      <p>The SYN library maintains a stack of syntax tree positions for
      use by the application during syntax tree traversal.  The stack is
      reset to empty when the tree is initialized for traversal.  The
      stack is reserved exclusively for application use.  The SYN library
      does not silently push or pop anything to/from the stack.

      <p>The routines for using the syntax tree position stack are:

</p><indent><p><pre>
procedure syn_trav_push (              {save curr syntax tree pos on internal stack}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;

procedure syn_trav_pop (               {restore curr syntax tree pos from stack}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;

procedure syn_trav_popdel (            {pop syn tree pos from stack, stay curr pos}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

      <p>The first pushes the current syntax tree position onto the stack,
      and the second pops the last-pushed position from the stack and goes
      to that position in the syntax tree.

      <p>The third routine pops the last-pushed entry from the stack, but
      does not change the syntax tree position.  This effectively discards
      the top stack entry.

      </p></indent>

    </p></indent>

  <h3>Current tree state</h3><indent>

    <p>Particularly for diagnostics and error messages, it can be useful
    for applications to get information about the current syntax tree
    level.  The routines for that purpose are:

</p><indent><p><pre>
function syn_trav_level (              {get nesting level of curr syntax tree pos}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {0-N, 0 at top level}
  val_param; extern;

procedure syn_trav_level_name (        {get the name of the current syntax tree level}
  in out  syn: syn_t;                  {SYN library use state}
  in out  name: univ string_var_arg_t); {returned name}
  val_param; extern;
</pre></p></indent>

    <p>The first returns the current nesting level.  0 indicates the top
    level. Each successive higher number indicates one more level down
    from the top.

    <p>The second routine returns the name of the current level.  This is
    the name of the syntax construction as used in the ".define" command
    in the syntax definition.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="testsyn_cust">Modifying TEST_SYN for custom syntax</h1>

<p>The <a href="../test_syn.txt">TEST_SYN</a> program shows the syntax
trees resulting from a syntax definition file.  It can be useful for
testing a custom syntax definition as it is being developed, and see the
syntax trees that the application processing that custom syntax will
encounter.

<p>The source code for the TEST_SYN program is in the "test_syn.pas" file.
This source is useful as an example of how to read an input file into
memory so that the syntaxer can access it, parsing the syntax, and walking
the resulting syntax trees.

<p>Very little of TEST_SYN is actually specific to processing the SYN
syntax, as opposed to any other syntax defined with the SYN language.  In
addition, the source is structured for easy customization.

<p>To make a version of TEST_SYN that parses a file according to a
different syntax, peform these steps:

<h2>Copy the source</h2><indent>

  <p>Make a copy of "test_syn.pas", and name it something different.  In
  this example, let's say your new syntax is named ABC, defined in
  ABC.SYN.  A possible name would be "test_abc.pas".

  </p></indent>

<h2>Set name of the top level syntax</h2><indent>

  <p>At least the top level syntax construction must have a known
  subroutine name.  This is done in the syntax definition file by
  supplying an explicit subroutine name for the syntax construction in the
  .SYMBOL command for that construction.  For example:

</p><indent><p><pre>
.symbol toplev[syn_ch_toplev]
</pre></p></indent>

  <p>This defines the existance of the syntax construction TOPLEV, and
  specifies its subroutine will have the name "syn_ch_toplev".  As
  mentioned before, subroutine names starting with "syn_ch_" are
  explicitly reserved for application-specific syntax parsing routines.

  <p>The TEST_SYN code that specifies the top level syntax parsing routine
  must be modified accordingly.  The existing section of code is:

</p><indent><p><pre>
(*
function syn_ch_xxx (                  {parse one top level construction}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {TRUE iff input matched expected syntax}
  val_param; extern;
*)

var
  top_syn_p: syn_parsefunc_p_t         {pointer to top syntax to parse}
    := addr(syn_chsyn_command);
</pre></p></indent>

  <p>The variable <tt>top_syn_p</tt> must point to the parsing routine for
  the top level syntax construction.  This is done in the last two lines
  above by declaring the variable of type <tt>syn_parsefunc_p_t</tt> and
  setting it to the initial value of the parsing routine address.  The
  value of this variable is not changed in the program, so this is just a
  way of specifying its fixed value.

  <p>The SYN syntax parsing routines must always be present in the SYN
  library, so they can not have names "syn_sy_xxx" to avoid colliding with
  application-specific names.  Names "syn_chsyn_xxx" are specifically
  reserved for SYN language parsing routines.  This is why
  <tt>top_syn_p</tt> is set to the address of <tt>syn_chsyn_command</tt>,
  above.  In the SYN language definition, the top level construction is
  called COMMAND, and it's parsing routine has the name
  "syn_chsyn_command".

  <p>In our example, <tt>top_syn_p</tt> must be set to the address of
  <tt>syn_ch_toplev</tt>.  However, symply changing the last line of the
  source snippet above is unsufficient because the routine SYN_CH_TOPLEV
  is not declared anywhere visible to this source file.  It only exists in
  the code generated from compiling the custom syntax definition.

  <p>A template declaration of a custom parsing routine is provided in the
  TEST_SYN source, but commented out.  That is because all the SYN
  language parsing functions <i>are</i> declared in the SYN library
  include file.

  <p>Therefore, to complete the customization of the TEST_SYN source to
  the SYN_CH_TOPLEV top level parsing routine, uncomment the template
  declaration and change its name accordingly.  The resulting source
  snippet in this example would be:

</p><indent><p><pre>
function syn_ch_toplev (               {parse one top level construction}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {TRUE iff input matched expected syntax}
  val_param; extern;

var
  top_syn_p: syn_parsefunc_p_t         {pointer to top syntax to parse}
    := addr(syn_ch_toplev);
</pre></p></indent>

  </p></indent>

<h2>Set input file name suffix</h2><indent>

  <p>TEST_SYN requires that input files end in a fixed suffix, intended to
  be unique to the particular syntax.  This suffix is set with the
  constant <tt>fnam_suffix</tt>:

</p><indent><p><pre>
const
  fnam_suffix = '.syn';                {mandatory input file name suffix}
</pre></p></indent>

  <p>Simply change ".syn" above.  In this example, we called the syntax ABC, so
we will use the file name suffix ".abc":

</p><indent><p><pre>
const
  fnam_suffix = '.abc';                {mandatory input file name suffix}
</pre></p></indent>


  </p></indent>

<p>That's it.  The new program TEST_ABC will read text files with names
ending in ".abc", parse them according to the ABC syntax (defined in
ABC.SYN), and show the resulting syntax trees.

<p>Note that the existing TEST_SYN program would be used to test the
ABC.SYN file, while the new TEST_ABC program would be used to test files
in the ABC language.


<!-- -------------------------------------------------------------------------->
<h1 id="cust_constr">Manually creating syntax parsing routines</h1>

<p>Syntax parsing routines are normally created automatically from a SYN
file.  However, they can also be created manually.  The requirements of
such routines and the run-time support they use in the SYN library are
documented here.

<p>The definition of a syntax construction in a SYN file is generally more
understandable, shorter, and easier to modify than the C code to implement
that syntax.  There are also various rules that must be followed.  It is
therefore recommended to let syntax parsing routines be automatically
created from the syntax definition in a SYN file unless there is an
overriding reason not to.  Such reasons can include:<ul>

  <li>To perform application-specific actions during parsing.

  <li>To implement features not available in the SYN language.

  <li>For efficiency.  A specific syntax routine might not require all the
  entry, exit, and other actions necessary in the general case.  It can
  also be possible that a particular syntax is complicated to describe in
  the SYN language, and can be implemented more simply with explicit code.

  <p>However, unless parsing an input stream is truly time-critical and a
  syntax construction is run many times in an inner loop, any efficiency
  improvements are likely minor if not invisible to the user.
  Understandability and ease of code maintainence are usually more
  important concerns than minor efficiency gains.

  </ul>

<p>The routines in the SYN library that are used by syntax parsing
routines have names starting with <tt>syn_p_</tt>.  Their interfaces are
publicly declared in the SYN library include files (SYN.INS.PAS and
SYN.H).

<h2>Subroutine interface</h2><indent>

  <p>All syntax parsing routines have the same required interface.  This
  is formally defined in SYN.INS.PAS by the data type that is a pointer to
  such a routine:

</p><indent><p><pre>
  syn_parsefunc_p_t = ^function (      {pointer to function to parse a construction}
    in out syn: syn_t)                 {SYN library use state}
    :boolean;                          {syntax matched, tree possibly extended}
    val_param;
</pre></p></indent>

  <p>A pointer to the top level routine for the syntax to parse must be
  passed to the SYN library to do the parsing and build the resulting
  syntax tree.

  <p>From the definition above, it can be seen that each syntax routine is
  a function that takes the SYN library use state as its single argument,
  and returns a boolean value.  That boolean value indicates whether the
  input stream matched the syntax or not.

  <p>A return value of TRUE means that the input matched the syntax, and
  the result added to the syntax tree being built.

  <p>A return value of FALSE means that the input did not match the
  syntax, and the syntax tree was not altered.  The parsing state is also
  reset to what it was on entry to the routine.  In other words, the
  routine had no net effect on the parsing state or the syntax tree.  It
  only indicated that the input did not match the specific syntax it
  parses.

  </p></indent>

<h2>Creating subordinate syntax tree level</h2><indent>

  <p>When compiled from a SYN file, each syntax construction is
  implemented in its own routine, and creates its own subordinate level in
  the resulting syntax tree.  However, that is only a convention.  A
  subordinate syntax tree level can be created at any time with the
  following routines:

</p><indent><p><pre>
procedure syn_p_constr_start (         {starting to parse a new syntax construction}
  in out  syn: syn_t;                  {SYN library use state}
  in      name: string;                {name of syntax construction being checked}
  in      namelen: sys_int_machine_t); {number of characters in NAME}
  val_param; extern;

procedure syn_p_constr_end (           {done parsing syntax construction, restore state}
  in out  syn: syn_t;                  {SYN library use state}
  in      match: boolean);             {input matched construction, tree extended}
  val_param; extern;
</pre></p></indent>

  <p>The first starts the new subordinate level, and the second ends it.
  The syntax tree level name is provided when the syntax level is created.

  <p>The parsing state is automatically saved when the level is created.
  Note the MATCH parameter to the routine that ends the syntax level. This
  indicates whether the input stream matched the syntax.  If the syntax
  did not match, then the syntax tree level is deleted and the parsing
  state is restored to when the syntax level was started.

  <p>All automatically generated syntax parsing routines start with
  <tt>syn_p_constr_start</tt>, and end with <tt>syn_p_constr_end</tt>.

  </p></indent>

<h2>Checking input stream characters</h2><indent>

  <h3>Get next input character</h3><indent>

    <p>As explained earlier, the syntaxer works by comparing the input
    stream to the syntax definition character by character.  The low level
    routine to get the next input character is:

</p><indent><p><pre>
function syn_p_ichar (                 {get next input char code, charcase applied}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {0-255 character code, or SYN_ICHAR_xxx_K}
  val_param; extern;
</pre></p></indent>

    <p>This either returns the character code as an unsigned integer from
    0 to 255, or one of the special characters defined by contants
    SYN_ICHAR_xxx_K.  These special characters have values less than 0,
    and are defined in SYN.INS.PAS as:

</p><indent><p><pre>
  syn_ichar_eol_k = -1;                {end of line}
  syn_ichar_eof_k = -2;                {end of current file (end of subordinate collection)}
  syn_ichar_eod_k = -3;                {end of all input data}
  syn_ichar_err_k = -4;                {err char reached on error re-parse}
</pre></p></indent>

    <p>EOL is indicated at the end of every input line.  This includes
    after the last line in a file.  A file that contains at least one line
    therefore always ends with EOL followed by EOF.  An empty file causes
    the single character EOF to be returned.

    <p>EOF is always returned at the end of any file.  There can be
    multiple EOFs in the input stream if there are nested files.  Each EOF
    indicates the input is popping back to the parent file.  The top level
    file, like all files, also ends in a EOF.

    <p>EOD is returned after the end of all data, which is the end of the
    top level input file.  Continued reading of the input stream will only
    return more EOD characters.

    <p>The special ERR character indicates the end of the syntax tree when
    it resulted from an error re-parse.  ERR is never returned from a
    syntax tree where the input matched the syntax.

    </p></indent>

  <h3>Character case</h3><indent>

    <p>Input stream letters can be forced to be read in lower case, upper
    case, or unaltered.  This is done with the following routine:

</p><indent><p><pre>
procedure syn_p_charcase (             {set charcase handling, restored at constr end}
  in out  syn: syn_t;                  {SYN library use state}
  in      ccase: syn_charcase_k_t);    {the new input stream character case handling}
  val_param; extern;
</pre></p></indent>

    <p>The CCASE parameter must be one of the following enumerated values:

</p><indent><p><pre>
  syn_charcase_k_t = (                 {how to handle input stream character case}
    syn_charcase_down_k,               {convert input to lower case}
    syn_charcase_up_k,                 {convert input to upper case}
    syn_charcase_asis_k);              {do not alter input stream characters (default)}
</pre></p></indent>

    <p>This case conversion only applies to characters returned by
    <tt>syn_p_ichar</tt>.  Actual input stream characters are not altered.
    Effectively, the character case setting is therefore only for syntax
    checking.  Applications will get the unaltered input characters when
    retrieving tagged sections of the input while traversing the syntax
    tree.

    <h4>Character case scope</h4><indent>

      <p>A character case conversion setting stays in effect until the end
      of the current syntax construction, as defined by
      <tt>syn_p_constr_start</tt> and <tt>syn_p_constr_end</tt>.  The
      current case conversion setting is inhereted when a syntax
      construction is started.  A single setting before any parsing
      therefore applies globally, but can be locally overridden separately
      in each syntax construction.

      <p>The default setting (<tt>syn_p_charcase</tt> never called) is
      ASIS.  In other words, <tt>syn_p_ichar</tt> returns characters
      exactly as they are in the input stream when no explicit character
      case setting is made.

      </p></indent>

    </p></indent>

  <h3>Higher level input-checking routines</h3><indent>

    <p>Several convenience routines are supplied that get the next
    character or characters and compare them to particular items.  These
    routines are layered on <tt>syn_p_ichar</tt>, so the current input
    stream character case conversion is applied.

    <p>These layered convenience routines return TRUE to indicate the
    input matched the expected value, and FALSE that it did not.  The
    input stream position is left after the characters when they matched,
    and is restored to before the characters when they did not match.  Put
    another way, the input characters are "consumed" when the input
    matched what was tested for.

    <p>The convenience input-checking routines are:

</p><indent><p><pre>
function syn_p_test_eol (              {check for at end of current line}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {at end of line}
  val_param; extern;

function syn_p_test_eof (              {check for at end of current logical input file}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {at end of input data}
  val_param; extern;

function syn_p_test_eod (              {check for at end of input data}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {at end of input data}
  val_param; extern;

function syn_p_test_string (           {check input for matching string}
  in out  syn: syn_t;                  {SYN library use state}
  in      str: string;                 {the string to compare to the input}
  in      strlen: sys_int_machine_t)   {number of characters in STR}
  :boolean;                            {input matched string, position left at end}
  val_param; extern;
</pre></p></indent>

    <p>The first three routines check for the special characters returned
    by <tt>syn_p_ichar</tt>: End of line (EOL), end of file (EOF), and end
    of all data (EOD).

    <p>The last routine checks the input against a fixed string.

    </p></indent>

  </p></indent>

<h2>Tagging input stream sections</h2><indent>

  <p>As detailed earlier, sections of the input stream can be tagged and
  referenced in the syntax tree.  A separate syntax tree entry is created
  for each tag.  A tag syntax tree entry is created with the following
  routines:

</p><indent><p><pre>
procedure syn_p_tag_start (            {start tagged section of input stream}
  in out  syn: syn_t;                  {SYN library use state}
  in      id: sys_int_machine_t);      {tag ID}
  val_param; extern;

procedure syn_p_tag_end (              {end tagged section of input stream}
  in out  syn: syn_t;                  {SYN library use state}
  in      match: boolean);             {input matched, create the tag}
  val_param; extern;
</pre></p></indent>

  <p>To create a tag, it is first started with <tt>syn_p_tag_start</tt>.
  Among other things, this saves the tag ID and the current location in
  the input stream in the internal SYN library parsing state.

  <p>Tag IDs must be 1 or greater.

  <p>A tag is either finalized or deleted with <tt>syn_p_tag_end</tt>.
  The MATCH parameter to <tt>syn_p_tag_end</tt> is used to indicate
  whether the input stream matched the required syntax since the tag was
  started.

  <p>When MATCH is TRUE, the tag is created and finalized to end at the
  current input stream position.

  <p>When MATCH is FALSE, creation of the tag is aborted, and state
  restored to what it was when <tt>syn_p_tag_start</tt> was called.  This
  includes the syntax tree state and the input parsing state.  The effect
  is as if <tt>syn_p_tag_start</tt> was never called, and no parsing
  activity occurred since then.

  <p>A new tag can be started before a previous one is finished.  However,
  tags are only created and ended in strict nesting order.  Only the
  last-started tag can be ended.

  <p>When a tag is ended with MATCH = FALSE, all new syntax tree entries
  since the tag was started are deleted.  <tt>syn_p_tag_end</tt> with
  MATCH = FALSE always restores the syntax tree and input stream state to
  when its matching <tt>tag_p_start</tt> was called, regardless of what
  may have been written to the syntax tree since then.

  </p></indent>

<h2>Saving and restoring input stream positions</h2><indent>

  <p>Checking the input stream against a particular syntax can sometimes
  require going back to an earlier position and trying again with a
  different choice thru the syntax definition.  There are two ways for
  parsing routines to save and restore input stream positions.

  <h3>Getting/setting input stream position explicitly</h3><indent>

    <p>The input stream position can be read at any time, and explicitly
    set to a previously saved position:

</p><indent><p><pre>
procedure syn_p_cpos_get (             {get the current parsing character position}
  in out  syn: syn_t;                  {SYN library use state}
  out     pos: fline_cpos_t);          {returned parsing position}
  val_param; extern;

procedure syn_p_cpos_set (             {set the current parsing character position}
  in out  syn: syn_t;                  {SYN library use state}
  in      pos: fline_cpos_t);          {character position to go to}
  val_param; extern;
</pre></p></indent>

    <p>In this case, the application is responsible for maintaining the
    <tt>fline_cpos_t</tt> structure that the input stream position is
    saved in.  The application can have any number of such structures with
    saved positions in them, and can go back to any of them at any time.

    <p>There is no requirement that a particular position ever be
    restored, or in what order saved positions are restored.

    <p>The SYN library saves no state on its own when
    <tt>syn_p_cpos_get</tt> is called.  It has no knowledge of positions
    that the application might have saved.

    </p></indent>

  <h3>Pushing/popping input stream position</h3><indent>

    <p>The SYN library also provides an input stream position stack for
    use by parsing routines:

</p><indent><p><pre>
procedure syn_p_cpos_push (            {push input character position onto parse stack}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;

procedure syn_p_cpos_pop (             {pop input character position from parse stack}
  in out  syn: syn_t;                  {SYN library use state}
  in      match: boolean);             {syntax matched, continue at curr input position}
  val_param; extern;
</pre></p></indent>

    <p>Input stream positions are saved onto an internal stack, and can
    only be restored in nested order.  Individual saved positions are not
    accessible to the application directly.

    <p>These stack-based routines have the additional feature of handling
    whether the input matched the expected syntax between a PUSH and POP.
    This is done by passing the MATCH parameter to
    <tt>syn_p_cpos_pop</tt>.

    <p>When MATCH = TRUE, the stack entry is popped and discarded.  The
    input stream position remains where it was.

    <p>When MATCH = FALSE, the input stream position is restored to the
    popped state.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="calc">CALC Example Application</h1>

<p>The subdirectory <tt>calc</tt> within the <tt>syn</tt> source code
repository contains an example program that uses the syntaxer.  This
program implements basic calculator functions entered from an interactive
command line.  While the calculator functions do work, this program's main
purpose is to serve as an example of using the syntaxer, not to be a
useful calculator.

<p>The <a href="../calc/calc.txt"><tt>calc.txt</tt></a> file describes how
the <tt>calc</tt> program functions.

<p>The <a href="../calc/calc.syn"><tt>calc.syn</tt></a> file is the syntax
definition of the calculator language.  This is what the <tt>calc</tt>
program parses and processes at run time.

<p>The <a href="../calc/test_calc.pas"><tt>test_calc</tt></a> program is
an example of <tt>test_syn</tt> modified to a custom syntax, the CALC
syntax in this case.  By default, <tt>test_calc</tt> reads
<tt>t.calc</tt>, parses it according to the CALC syntax, and then shows
the resulting syntax trees.


</body></html>
