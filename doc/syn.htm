<html lang="en-US">
<head>
  <link rel="stylesheet" href="document.css"></link>
  <title>SYN</title>
  </head>
<body>

<h1 class=page>Embed Syntaxer User's Guide</h1>
<p class=page>Last updated 21 Jan 2024</p>

<ul>
  <li><a href="#intro">Introduction</a><ul>
    <li><a href="#intro_usage">Usage overview</a>
    <li><a href="#intro_comp">Components</a>
    </ul>
  <li><a href="#source">Source Code</a><ul>
    <li><a href="#source_git">GIT repositories</a><ul>
      <li><a href="#source_git_build">Setting up source to be buildable</a>
      </ul>
    </ul>
  <li><a href="#instream">Input Stream</a><ul>
    </ul>
  <li><a href="#syn">Syntax Definition</a><ul>
    <li><a href="#syn_char">Character by character</a>
    <li><a href="#syn_constr">Syntax constructions</a>
    <li><a href="#syn_subrname">Subroutine names</a>
    <li><a href="#syn_ext">External parsing routines</a>
    <li><a href="#syn_padspace">PAD and SPACE constructions</a>
    <li><a href="#syn_tag">Tagging syntax items</a>
    </ul>
  <li><a href="#synlib">Using the SYN Library</a><ul>
    <li><a href="#synlib_doc">Documentation</a>
    <li><a href="#synlib_lib">Library management</a>
    <li><a href="#synlib_parse">Parsing the Input Stream</a>
    <li><a href="#synlib_tree">Traversing the Syntax Tree</a>
    </ul>
  <li><a href="#syncalc">SYNCALC Example Application</a><ul>
    </ul>
  <li><a href="#testsyn_cust">Modifying TEST_SYN for custom syntax</a><ul>
    </ul>
  <li><a href="#cust_constr">Manually creating syntax parsing routine</a><ul>
    </ul>
  </ul>


<!-- -------------------------------------------------------------------------->
<h1 id="intro">Introduction</h1>

<p>The Embed Inc syntaxer is a library and programs to help software parse
and act on complex formal languages.  At a high level, the syntaxer
provides these services:<ol>

  <li>Validate an input stream as adhering to a syntax specification.

  <li>Discard the syntax details that are no longer relevant once the
  input stream is verified.

  <li>Identify and pass on only the parts of the validated input stream
  that must be acted upon, with syntax details stripped to the extent
  possible.

  </ol>

<h2 id="intro_usage">Usage overview</h2><indent>

  <p>The steps for the developer of an application to use the syntaxer are
  briefly listed here.  Subsequent sections of this document go into
  details.  At a high level, the steps for building an application to
  parse complex syntax with the Embed syntaxer are:<ol>

    <li>Define the syntax to parse using the SYN syntax definition
    language.  The SYN language is described in the <a
    href="../syn_file.txt">syn_file</a> documentation file.  This step
    amounts to writing a .syn file.

    <li>Compile the SYN file.  This is done with the Embed <a
    href="../../sst/sst.txt">SST</a> program, or the more specific <a
    href="../../sst/syn.txt">SYN</a> program.  The result of this step is
    C code that makes calls into the SYN library.  This code will parse
    the input stream and build the resulting syntax tree specific to the
    syntax definition it was compiled from.

    <li>Compile the C file from the previous step to a relocatable object
    file.  This object file will need to be linked with the application
    when that application is built.

    <li>Add calls to the application to use the SYN library to parse the
    input, build the syntax tree, then traverse that syntax tree and
    perform the specified actions.

    <li>When the application is built, the compiled object resulting from
    the SYN file must be linked to it.  The SYN library, and various
    additional Embed libraries used by SYN must also be statically linked
    to the application.

    </ol>

  </p></indent>

<h2 id="intro_comp">Components</h2><indent>

  <p>The overall syntaxer facility includes various software components:

  <h3>SYN library</h3><indent>

    <p>The SYN library is the run-time component of the syntaxer.  It must
    be linked to applications using the syntaxer.  Include files
    specifying the run-time interface are provided in C and Embed Pascal.
    The library provides procedural interfaces for:<ul>

      <li>Starting and ending independent uses of the SYN library.  The
      library supports multiple concurrent uses, each with its own state.

      <li>Parsing a collection of input lines according to a syntax
      definition, and building a syntax tree with the parts that are
      tagged in the syntax definition to pass on to the application.

      <li>Traversing the syntax tree, and retreiving the tagged items. The
      original input stream text for each syntax tree element can be
      identified and retrieved.

      <li>Emitting error, debug, and other messages related to syntax tree
      components, their location in the input stream, and appropriate
      snippets from that input stream.

      <li>Low level generic facilities used during parsing.  These are not
      usually accessed by the appliction directly.  They are called by the
      custom parsing code for a particular syntax.  This section of the
      SYN library provides the interface expected by the code compiled
      from the syntax definition file.

        <p>In special cases, the application may create specific syntax
        parsing routines "manually", by using these facilities directly
        instead of implicitly via the custom-compiled syntax parsing code.

      <li>Routines for parsing the SYN syntax definition language.  These
      are mostly derived from the <a href="../syn.syn">SYN.SYN</a> syntax
      definition file.  This file describes the SYN language syntax, using
      the SYN language.

      </ul>

    </p></indent>

  <h3>SST program</h3><indent>

    <p><a href="../../sst/sst.txt">SST</a> is the Embed source-to-source
    translator.  It is used to create C code from a syntax definition by
    using the SYN front end and C back end.

    </p></indent>

  <h3>SYN program</h3><indent>

    <p><a href="../../sst/syn.txt">SYN</a> is a custom version of SST that
    only compiles SYN files to C source.  It is less flexible than SST,
    but is all that is needed to create C source from syntax definition
    files.  SYN is intended for convenience when the full features of SST
    are not required.

    </p></indent>

  <h3>TEST_SYN program</h3><indent>

    <p><a href="../test_syn.txt">TEST_SYN</a> is a test program that shows
    the syntax tree resulting from a .syn file.  It can be useful to see
    the resulting syntax tree when writing a syntax definition.

    <p>The source code (<a href="../test_syn.pas">test_syn.pas</a>) also
    serves as a template for programs to provide the same function for
    other languages.  TEST_SYN always parses its input file according to
    the SYN language.  Only minor modifications are necessary to instead
    parse a different language specified by a different .syn file.
    Customizing TEST_SYN for a different language is detailed in a <a
    href="#testsyn_cust">later section</a> of this document.

    </p></indent>

  <h3>Other Embed libraries</h3><indent>

    <p>The SYN library is layered on other Embed libraries that must also
    be linked to the application.  These are SYS, UTIL, STRING, FILE, and
    FLINE.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="source">Source Code</h1>

<p>The syntaxer, as with most Embed software, is written in the Embed
Pascal language.  The details of this language are embodied in the
source-to-source translator (SST) program Pascal front end.  Pascal
modules are built by first translating them to C with SST, then compiling
the C code with commonly available compilers.

<p>Source code examples will be shown in the Embed Pascal language in this
document.  Readers generally familiar with Pascal or C should be able to
follow along.  It is not the purpose of this document to teach or explain
the Embed Pascal Language.

<h2 id="source_git">GIT repositories</h2><indent>

  <p>All source code for the syntaxer and components it relies on is open
  and available in GIT repositories on GitHub.

  <h3 id="source_git_build">Setting up source to be buildable</h3><indent>

    <p>This document assumes that the Embed full runtime sofware has been
    installed, local copies of the GIT source code repositories have been
    made, and the source can be built using the supplied build scripts.
    The Embed environment can be set up accordingly by going to the Embed
    <a href="http://www.embedinc.com/pic/dload.htm">software downloads
    page</a>, installing the full runtime environment, and following the
    directions to get the source code and set it up to be buildable.
    Tools for building Microchip PIC code need not be installed to use the
    syntaxer.

    <p>If the BUILD_HOST script runs without errors, then everything is
    set up properly.

    <p>Links in this document assume it is in the DOC directory in the SYN
    source repository, within the Embed SOURCE tree on the local machine.

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="instream">Input Stream</h1>

<p>The input stream to be parsed by the syntaxer must be stored in memory.
Specifically, it must be in a collection of lines managed by the <a
href="../../fline/fline.ins.pas">FLINE</a> library.  This may seem
cumbersome at first, but it provides important advantages:<ol>

  <li>Allows going back and forth.  The syntaxer reads the input stream
  while following the syntax definition.  This may result in going down
  "dead ends" and backtracking where there are multiple possible syntax
  paths, until the path that matches the input is found.

    <p>Even if the syntaxer read an input stream "live", it would still
    need to store all that it read to be able to go back and take a
    different syntax branch from an earlier point.

  <li>Allows pointers to input stream sections.  Tagged sections of the
  input syntax are stored on the syntax tree.  Instead of making copies of
  the input stream sections, pointers are stored to the single copy of the
  input stream.

  <li>The application can manage getting the input stream.  There are many
  possible ways the input stream could be acquired beyond just reading it
  from a file.  It could be entered live by a user, the result of
  pre-processing a set of files, or generated entirely by the application.
  These possibilities should not be limited or dictated by the syntaxer.

  <li>Input files hierarchy is not lost.  The FLINE library allows for
  maintaining a flattened text stream that originated from a tree of input
  files, while still knowing what part of the original source each line
  was derived from.  This can be useful for emitting meaningful error
  messages to the user, for example.

    <p>A tree of files could be interpreted by a pre-processor, for
    example. Facilities in the FLINE library allow the pre-processor to
    indicate the location in the complete hierarchy of files that each
    output line results from.  Such a pre-processor is not limited to only
    expanding "include" directives.  There need not be a one-to-one
    correspondence of input lines to output lines.

    <p>The Embed pre-processor, <a
    href="../../escr/doc/index.htm">ESCR</a>, is an example of a
    pre-processor that can write its output to an FLINE source lines
    collection.

  <li>Each input file is only stored once.  If a tree of input files is
  flattened to create the syntaxer input stream, some low level input
  files may be referenced multiple times.  The FLINE library allows for
  storing each input file only once, but still maintaining the full
  hierarchy reference for each resulting output line.

  </ol>

<p>While the FLINE library allows for great flexibility, it also provides layered
routines for performing the simple cases simply.  For example, here is the entire code
from the TEST_SYN program that creates an FLINE collection of lines from the input
file:

<pre>
  fline_lib_new (                      {open the FLINE library}
    util_top_mem_context,              {parent memory context}
    fline_p,                           {returned pointer to new library use state}
    stat);
  sys_error_abort (stat, '', '', nil, 0);

  fline_file_get_suff (                {read the input file into a collection}
    fline_p^,                          {FLINE library use state}
    fnam_in, '.syn',                   {file name and mandatory suffix}
    coll_p,                            {returned pointer to the collection}
    stat);
  sys_error_abort (stat, '', '', nil, 0);
  </pre>

<p>The result of this code section is that <tt>coll_p</tt> is set pointing
to the input lines ready to pass to the syntaxer.

<p>The details of the FLINE library are beyond the scope of this document.
Since it is not relevant to the syntaxer how the input stream was acquired
or derived, examples in this document will assume the simplified case
where it is read directly from a single input file.


<!-- -------------------------------------------------------------------------->
<h1 id="syn">Syntax Definition</h1>

<p>The syntax that the syntaxer is customized to parse in any one instance
is defined by a syntax definition file.  The name of this file always ends
in ".syn".  This SYN file ultimately results in executable code specific
to the particular syntax.  This code is then linked with the application
and the SYN library.

<p>The SYN file is therefore only used in building the application.  It is
not read at run time.  If the syntax is changed, the SYN file must be
changed accordingly and the application re-built for the change to take
effect.

<p>The SYN file language is described in the <a
href="../syn_file.txt">syn_file</a> documentation file.  The remainder of
this document assumes the reader understands the syntax definition
language.

<h2 id="syn_char">Character by character</h2><indent>

  <p>Unlike some other syntax parsing systems, the input stream is not
  "tokenized" or otherwise processed in multiple stages.  At run time, the
  syntaxer matches the input stream to the syntax definition character by
  character.  If there needs to be a space or new line at some point, for
  example, then that must be explicitly stated in the syntax definition.

  <p>In this sense, the syntaxer is "dumb".  It simply compares the
  current input character to the current point in the syntax definition.
  If they match, then it continues to the next character.  If they do not
  match, then it pops back to the last decision point (in both the syntax
  definition and the input stream) and tries the next possible syntax
  branch.

  <p>If no branches thru the syntax possiblities match the input stream,
  then there is a syntax error.  The syntaxer saves the furthest point in
  the input stream that did match the syntax, and indicates error at the
  next character.  The application can get this location in the input
  stream.  It can also traverse the partial syntax tree to the error
  point, which may provide some semantic context for the error.

  </p></indent>

<h2 id="syn_constr">Syntax constructions</h2><indent>

  <p>A particular syntax is defined by a nested series of syntax
  constructions.  Each named symbol in the SYN file is one construction. A
  construction results in one syntax parsing subroutine in the compiled
  syntax code, and a separate subordinate level in the syntax tree after
  parsing.

  <p>Within a construction, syntax is defined as a sequence of "items"
  called an "expression".  Items are those built into the syntax
  definition language, or subordinate constructions specified by the
  construction name.  An expression in parenthesis becomes a single item.
  This allows expressions to be nested.

  <p>There is no fixed rule as to how the overall syntax should be broken
  into separate constructions.  Deciding what to include in-line in an
  existing construction versus creating a subordinate construction is much
  like deciding what to put in a single routine versus breaking it into
  multiple subordinate subroutines.  However, the following should be kept
  in mind:<ul>

    <li>Each construction creates its own nested level in the syntax tree.

    <li>The name of the construction for a particular syntax tree level
    can be determined by the application when traversing the syntax tree.
    This can aid in debugging and in providing more useful information for
    error messages.  Note that the TEST_SYN program shows the construction
    name at the start of each syntax tree level.

    <li>The current nested list of construction names is maintained as the
    input stream is parsed.  This hierarchy can be shown to the user for
    debugging purposes and in error messages.

    </ul>

  <p>In general, it is good to create a separate construction for any
  recurring syntax.  For example, consider the INTEGER construction of the
  SYN language:</p><indent>

<pre>
.define INTEGER .as
  .occurs [1 to INF] .range ['0' thru '9']
</pre></indent>

  <p>This is a simple integer, comprised of one or more sequential decimal
  digits.  The INTEGER construction is then used in several places in the
  SYN definition.

  <p>It can also be useful to have the application code that processes the
  syntax tree have a separate subroutine for each construction.

  <p>In this example, it would make sense to have a separate subroutine to
  get an integer value.  The subroutine expects to be in the parent syntax
  level, with the next entry being the subordinate INTEGER level.  The
  subroutine goes down into the subordinate level, gets the digit
  characters, interprets them into an integer value, and pops back up to
  the parent level while returning the integer value.  In the parent
  routine, the subortinate INTEGER is treated like a single entity.

  <p>Consideration should therefore be given to how the syntax tree
  traversing code will be structured when deciding how to break up a
  syntax into nested constructions.

  </p></indent>

<h2 id="syn_subrname">Subroutine names</h2><indent>

  <p>As stated before, each syntax construction in the SYN file results in
  a separate parsing subroutine.  By default, these subroutine names are
  automatically generated.  Applications do not need to know the names of
  most syntax parsing routines because they will only be called from other
  syntax parsing routines.

  <p>However, at least the top level parsing routine must be known to the
  application, since the application must supply a pointer to the routine
  to start parsing.  For this reason, a fixed subroutine name can be
  specified in the .SYMBOL command for the construction.

  <p>In general, it is recommended that only those parsing routines
  referenced directly by the application be named, and that the names be
  SYN_CH_xxx.  Names starting with SYN_CH_ are reserved for parsing
  routines and are not used in the SYN library.

  <p>In this respect, do not use the SYN syntax definition as a guide. All
  routines were explicitly named to avoid name collisions with
  user-generated parsing routines since the SYN parsing routines are
  always part of the SYN library.  The SYN parsing routines are named
  SYN_CHSYN_xxx, where XXX is the construction name.  Nothing else in the
  SYN library is named starting with SYN_CHSYN_, so these routines are
  effectively in their own namespace.

  </p></indent>

<h2 id="syn_ext">External parsing routines</h2><indent>

  <p>SYN constructions provide a compact and reasonably user-friendly
  means to describe the actions of syntax parsing routines.  The actual
  code generated by the SYN program is much more verbose, harder to
  understand, and harder to modify.  Fortunately this complexity and
  obfuscation is largely irrelevant since these routines are written by
  machine.

  <p>However, there is no requirement that syntax parsing routines
  <i>must</i> only be generated by the SYN compiler.  The interface used
  by the parsing routines is documented and exported by the SYN library.
  These are routines with names SYN_P_xxx.

  <p>It is possible to manually write a parsing routine by using the same
  interface as SYN-generated parsing routines.  This can allow for
  features not available via the SYN language, or to perform other
  application-specific actions during parsing.

  <p>Writing your own syntax parsing routine is an advanced concept
  covered in a <a href="#cust_constr">later section</a> of this document.

  <p>The SYN language provides a means to indicate a syntax construction
  is not defined in the SYN file, and that its parsing routine is
  implimented externally to the automatically-created parsing routines.
  This mechanism is the optional EXTERN keyword in the .SYMBOL command.
  When the contruction is declared EXTERN, then its subroutine name must
  be explicitly given.  The externally defined construction can then be
  used like any other syntax construction in the remainder of the SYN
  file.

  </p></indent>

<h2 id="syn_padspace">PAD and SPACE constructions</h2><indent>

  <p>As mentioned before, there is no separate tokanizer or other
  pre-parsing pass over the input stream.  Not all syntaxes can be
  described as a sequence of tokens, and there is never a need to specify
  them that way.

  <p>However, allowing or requiring one or more spaces between syntax
  items is common to many languages, including the SYN language.  These
  functions are implemented with the PAD and SPACE constructions in the
  SYN language definition.

  <p>The SYN language is comprised of flowed text, meaning that end of
  line is a separator like space.  This also means that indentation per
  line is irrelevant.

  <p>The PAD construction allows for any number of separators.  These are
  space, end of line, and end of nested file.  End of line comments are
  also automatically skipped over.

  <p>SPACE is the same thing except that at least one separator is
  required.

  <p>As mentioned in the <a href="#syn_subrname"><i>Subroutine
  names</i></a> section (above), all the SYN language parsing routines are
  part of the SYN library with fixed names.  The PAD and SPACE parsing
  routines are therefore always available, with names
  <tt>syn_chsyn_pad</tt> and <tt>syn_chsyn_space</tt>, respectively. These
  two syntax parsing routines were written manually to exploit efficiency
  made possible by special characteristics of these constructions.  There
  is more detail on this in a later section about <a
  href="#cust_constr">writing your own syntax parsing routines
  directly</a>.

  <p>If the SYN PAD and SPACE constructions happen to match the
  requirements of a custom syntax, then they can be used directly.  To do
  that, declare the constructions EXTERN, and provide the routine names
  given above.  Note that the constructions do not need to be called "PAD"
  and "SPACE", but the routine names must be referenced verbatim.

  </p></indent>

<h2 id="syn_tag">Tagging syntax items</h2><indent>

  <p>One of the powerful features of the syntaxer is that it only passes
  on to applications those parts of the input stream that are relevant
  after all the syntax details have been verified.  For example, consider
  the simple Pascal assignment statement:

  <pre>
    <i>variable</i> := <i>expression</i>;
    </pre>

  <p>After all the syntax details have been checked, the application only
  needs to act on the variable name and the expression string.  The ":="
  assignment operator and ending ";" no longer matter after they have been
  verified.  The syntaxer would also probably verify that the variable
  name contained only certain characters, and didn't include a space.
  There would also likely be basic syntactical validation of the
  expression.

  <p>Passing on only selected parts of the parsed input for semantic
  processing is done by "tagging" those parts of the input.  In this
  example, the variable name and expression would be tagged.  Tagging is
  done by appending a number in brackets immediately after the syntax item
  being tagged.  This number must be a simple decimal integer of 1 or
  greater.

  <p>For example, here is a possible assignment statement syntax
  definition:

  <pre>
  .define assignment .as
    variable[1] pad ":=" pad expression[1] pad ";"
  </pre>

  <p>In this example, the PAD construction allows for zero or more
  separators, like blanks and new lines.  VARIABLE and EXPRESSION are
  syntax constructions defined separately.

  <p>When an assignment statement is parsed, only links to the variable
  name and the expression string are added to the syntax tree.  In this
  case, both are tagged with the ID of 1.  The ID values in this case are
  arbitrary since they are not necessary for determining which syntax path
  was taken.  Once in the ASSIGNMENT syntax tree level, there are always
  two tagged items.  These are the variable name and the expression string
  in that order.

  <p>When the application traverses the syntax tree and finds an
  assignment statement, it first goes down into the subordinate assignment
  statement tree level. There it gets the string for the first tag and
  interprets it as the variable name.  It gets the second tag and
  interprets it as an expression.  Note that the ":=" assignment operator,
  the ending ";", and possible intersperced blanks and new lines are not
  considered at this point.  This syntax tree content wouldn't be here if
  those syntax details weren't correct.

  <p>In some cases, the tag IDs are used to indicate which syntax branch
  was taken.  To continue with our Pascal statement example, an excutable
  statement definition could be:

  <pre>
  .define exec_statment .as
    .
    .
    .
    assignment[5] .or
    subroutine_call[6] .or
    for_loop[7] .or
    .
    .
    .
    </pre>

  <p>In this case, the statement only matches one of the syntax choices.
  If it is an assignment statement, the next syntax tree item will be tag
  5, if a subroutine call tag 6, etc.  In this case it is up to the SYN
  file writer to ensure that the tags for each choice are unique.

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="synlib">Using the SYN library</h1>

<p>This section describes how to use the SYN library from the
application's point of view.  The application-visible interface to the SYN
library is defined in the syn.ins.pas include file (and syn.h, which is
derived from syn.pas).  It may be helpful to refer to the include file
while reading this section.


<h2 id="synlib_doc">Documentation</h2><indent>

  <p>Descriptions about using the SYN library is in several different
  places:

  <h3>SYN.HTM (this file)</h3><indent>

    <p>The file you are reading now (SYN.HTM in the SYN repository DOC
    subdirectory) is intended to be the first level of documentation.  It
    provides an introduction, overview, and then details of using the SYN
    library.  This file is intended to be read before writing any
    application code.

    </p></indent>

  <h3>SYN.INS.PAS comments</h3><indent>

    <p>The comments in the Pascal include file (syn.ins.pas) provide quick
    reminders about the various routines, arguments, and data structures.
    It is intended to be referred to continually when writing application
    code, once a basic understanding of the library has been achieved.

    </p></indent>

  <h3>Source code header comments</h3><indent>

    <p>Each routine is described in more detail in its header comments
    immediately above the source code implementing that routine.  These
    comments are meant to provide the definitive details for using each
    routine.

    <p>Routines are grouped by function using a naming hierarchy. The
    names of all public symbols in the SYN library start with "syn_". Each
    successive "word" in the names provides more detail, until eventually
    the name becomes unique.  For example, the library managenment routine
    names start with "syn_lib_", and the routines for traversing a syntax
    tree "syn_trav_".

    <p>Routines are usually grouped into source files by this same naming
    hierarchy.  The "syn_lib_" routines are in the "syn_lib.pas" file, and
    the syntax tree traversing routines in the "syn_trav.pas" file, for
    example.  Particularly large or complex routines may be in their own
    files with more specific names.  While this file naming scheme is
    generally followed, there may be exceptions.  A pattern search over
    the "syn_*.pas" files may need to be performed to find the source code
    of a particular routine.

    <p>It is intended that the header comments in the source code of
    particular routines will be occasionally referenced when writing
    application code.

    </p></indent>

  <h3>Source code</h3><indent>

    <p>If all else fails, read the source code.  This is not intended to
    be necessary, but all the other documentation is never going to be
    perfect.  The source code is written such that the logic flow can be
    followed by largely reading the comments, but again, nothing is
    perfect.

    </p></indent>

  </p></indent>


<h2 id="synlib_lib">Library management</h2><indent>

  <p>The state for each use of the SYN library is kept in a <tt>syn_t</tt>
  data structure.  This data is dynamically allocated when a new use of
  the SYN library is started, and released when the library use is ended.
  The application must keep a pointer to the SYN library use state, and
  pass the use state when calling SYN library routines.

  <p>The routines for library management are:</p><indent>

<p><pre>
procedure syn_lib_new (                {create new use of the SYN library}
  in out  mem: util_mem_context_t;     {parent mem context, will create subordinate}
  out     syn_p: syn_p_t);             {pointer to new SYN library use state}
  val_param; extern;

procedure syn_lib_end (                {end a use of the SYN library}
  in out  syn_p: syn_p_t);             {pointer to lib use state, returned NIL}
  val_param; extern;
</pre></p></indent>

  <p>The first routine allocates and initializes a new library use state,
  and passes back <tt>syn_p</tt> pointing to it.

  <p>The Embed tree-structured dynamic memory facility is used.  Dynamic
  memory is always allocated under a "memory context".  These contexts can
  be tree structured.  Deleting a memory context automatically deletes any
  subordinate contexts, and deallocates all dynamic memory allocated to
  those subordinate contexts.  The tree-structured dynamic memory routines
  are in the UTIL library.

  <p>A private memory context is always created for each SYN library use.
  All dynamic memory allocated by a library use is therefore automatically
  deallocated when that library use is ended.

  <p>Applications can create their own dynamic memory context that a SYN
  library use will be subordinate too.  If this is not needed, the top
  level (root) memory context can be used as the parent for the private
  SYN library memory context.  This top memory context is called
  <tt>util_top_mem_context</tt>.

  <p>For example, the TEST_SYN program uses the top memory context for the
  parent:</p><indent>

<p><pre>
  syn_lib_new (                        {open the SYN library}
    util_top_mem_context,              {parent memory context}
    syn_p);                            {returned pointer to new library use state}
</pre></p></indent>

  <p>Subsequent SYN routines are passed the SYN library use state by
  reference.  Note that in Pascal this is done by passing the use state
  directly (not a pointer to it) with <tt>syn_p^</tt>.  However, since
  this argument is declared <tt>in out</tt> in each routine template, the
  compiler actually passes a pointer to the use state.

  <p>Ending a use of the SYN library is very simple.  From TEST_SYN:</p><indent>

<p><pre>
  syn_lib_end (syn_p);                 {end this use of the SYN library}
</pre></p></indent>

  <p>Unlike the normal "working" routines of the SYN library,
  <tt>syn_lib_end</tt> is explicitly passed a pointer to the use state.
  Since this routine ends a library use and deallocates all its dynamic
  memory, including the use state, the pointer is returned NIL.

  </p></indent>

<h2 id="synlib_parse">Parsing the input stream</h2><indent>

  <p>Once a SYN library use has been created, the next step is to parse
  the input stream.  While the documentation refers to the input "stream",
  it is actually a collection of source lines managed by the FLINE
  library.  See the TEST_SYN program for an example of reading the
  contents of a file into an FLINE library collection of lines.

  <p>Parsing is done in two steps.  First the current position within the
  input stream is set, then a parse initiated from that position.

  <p>The current input stream position can be set to the start of a
  collection of lines with:

</p><indent><p><pre>
procedure syn_parse_pos_coll (         {set parse position to start of collection}
  in out  syn: syn_t;                  {SYN library use state}
  in var  coll: fline_coll_t);         {collection to go to start of}
  val_param; extern;
</pre></p></indent>

  <p>Parsing from the current position is initiated with:

</p><indent><p><pre>
function syn_parse_next (              {parse, continue from current position}
  in out  syn: syn_t;                  {SYN library use state}
  in      syfunc_p: syn_parsefunc_p_t) {top level syntax to parse against}
  :boolean;                            {no error, syntax tree built}
  val_param; extern;
</pre></p></indent>

  <p>The function returns TRUE if parsing was successful and a syntax tree
  built, or FALSE if a syntax error was encountered.  In the latter case,
  no syntax tree is built.  There is more on handling syntax errors below.

  <p>If parsing from the start of a collection of lines, then the
  convenience routine

</p><indent><p><pre>
function syn_parse_coll (              {parse from start of collection of lines}
  in out  syn: syn_t;                  {SYN library use state}
  in var  coll: fline_coll_t;          {collection of input lines to parse}
  in      syfunc_p: syn_parsefunc_p_t) {top level syntax to parse against}
  :boolean;                            {no error, syntax tree built}
  val_param; extern;
</pre></p></indent>

  <p>can be used.  This combines <tt>syn_parse_pos_col</tt> and
  <tt>syn_parse_next</tt> into a single call.

  <p>Note that a pointer to the top level syntax construction is passed to
  <tt>syn_parse_next</tt>.  This is how the code resulting from compiling
  the .SYN syntax definition file is invoked.  This also means that at
  least the top level syntax construction must be given an explicit name
  in the .SYN file.

  <p>For example, the top level syntax construction of the SYN language is
  <tt>command</tt>.  This syntax construction symbol is therefore given an
  explicit subroutine name in SYN.SYN:

</p><indent><p><pre>
.symbol command[syn_chsyn_command]
</pre></p></indent>

  <p>A pointer to this subroutine is then passed to
  <tt>syn_parse_next</tt> in TEST_SYN to initiate parsing of the next
  command:

</p><indent><p><pre>
  match := syn_parse_next (            {parse from the current position}
    syn_p^,                            {SYN library use state}
    addr(syn_chsyn_command));          {top level syntax construction to parse}
</pre></p></indent>

  <p>In this case, <tt>match</tt> is a boolean variable that will indicate
  whether the input stream matched the syntax definition.  Successful
  parses and parses that encountered a syntax error must be handled
  differently.

  <h3>After successful parse</h3><indent>

    <p>When <tt>syn_parse_next</tt> returns TRUE, the input stream matched
    the syntax definition, and a syntax tree was built.  The application
    would then usually proceed to traversing the syntax tree.  See <a
    href="#synlib_tree"> <i>Traversing the Syntax Tree</i></a>, below.

    </p></indent>

  <h3>After syntax error</h3><indent>

    <p>When <tt>syn_parse_next</tt> returns FALSE, the input stream did
    not match any path thru the syntax definition.  This means there is a
    syntax error in the input stream.

    <p>Because of how the parser works, only an empty syntax tree results
    from a syntax error.  The parser matches the input stream against the
    syntax definition.  When a choice is encountered in the syntax
    definition, the parser saves the location of both the input stream and
    the syntax definition at that point.  If subsequent parsing does not
    match the syntax branch taken, state is restored to the decision point
    and the next syntax branch tried.

    <p>When there is a syntax error, there is no valid path thru the
    syntax definition, so eventually state is restored to the starting
    point.  When there are no more syntax choices to test, then the parse
    is aborted and <tt>syn_parse_next</tt> returns FALSE.

    <p>Some of the syntax branches might be more "right" than others, but
    the parser can not determine that since they are all ultimately wrong.
    To allow getting more information about a syntax error, the first
    input stream position that did not match any syntax branch is saved.
    This position can be retrieved with:

</p><indent><p><pre>
procedure syn_parse_err_pos (          {get the position of error after failed parse}
  in out  syn: syn_t;                  {SYN library use state}
  out     epos: fline_cpos_t);         {position of first char not to match syntax}
  val_param; extern;
</pre></p></indent>

    <p>The application can find the original source file, line number,
    character position, line contents, and other information from the
    returned error position.  This can be useful, for example, in emitting
    a meaningful error message to the user.  If this is the intent, the
    convenience routine

</p><indent><p><pre>
procedure syn_parse_err_show (         {show error position after failed parse}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

    <p>can be used.  This shows the input file hierarchy at the error
    position, the line containing the error, and the offending character.

    <h4>Error re-parse</h4><indent>

      <p>If only some or one syntax path reached the syntax error
      position, then more context can be provided for the syntax error.
      For example, consider the invalid Pascal assignment statement:

</p><indent><p><pre>
  ii := ++$^;
</pre></p></indent>

      <p>The syntax is valid past the ":=" indicating an assignment
      statement.  This additional information can be useful in emitting a
      more helpful error message to the user.  Instead of merely pointing
      to the second "+" as a syntax error, the error message could
      indicate "Invalid expression in assignment statement", for example.

      <p>To get this additional context, the parse can be re-done, but
      stop with a partially-built syntax tree when the error position is
      reached.  This is done by performing an error re-parse:

</p><indent><p><pre>
procedure syn_parse_err_reparse (      {reparse after error, builds tree up to err}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

      <p>This routine must only be called with the state left after a
      parse that resulted in a syntax error.  The syntax tree of the first
      path thru the input stream that matched everything up to the error
      position will result.  The application can then traverse the partial
      syntax tree to get more information about what was expected at that
      point.

      <p>Note that emitting a pure syntax error message with the error
      position can still be useful, even if followed up by a more
      context-specific error message.

      </p></indent>

    </p></indent>

  <h3>Continuing to next parse</h3><indent>

    <p>Depending on the syntax definition, each parse may only consume
    part of the input stream.  This is the case, for example, with the SYN
    syntax definition.  One <tt>command</tt> construction is parsed and
    handled at a time, with the input stream containing successive
    <tt>command</tt> constructions.

    <p>A successful parse leaves the input stream position after the
    last-consumed input character.  Therefore <tt>syn_parse_next</tt> can
    be called after done with the result of the previous parse.  This is
    in fact what TEST_SYN does.

    <p>The input stream will of course end at some point.  This could be
    handled by specifying the <tt>.eod</tt> (end of data) item in the
    syntax definition with a unique tag.  However, it is often convenient
    for the application to check whether the whole input stream has been
    consumed.  This can be done with:

</p><indent><p><pre>
function syn_parse_end (               {check for at end of input}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {parse position is after all data}
  val_param; extern;
</pre></p></indent>

    <p>The function returns TRUE if the parse position is after all data,
    and FALSE otherwise.

    </p></indent>

  </p></indent>

<h2 id="synlib_tree">Traversing the Syntax Tree</h2><indent>

  <p>A syntax tree is left after a successful parse or an error re-parse.
  The syntax tree contains a sequence of entries in a tree structure.
  These entries are either parts of the input stream deliberately tagged
  by the syntax definition, or used to define the tree structure.

  <p>Each level in the syntax tree has an entry that indicates its start
  and end.  A level can also contain entries that point to subordinate
  syntax tree levels.  Each of those has a start and end, and can point to
  lower syntax tree levels, etc.

  <p>The special error-end entry only exists in a tree resulting from an
  error re-parse.  It can occur at any level, and marks the farthest point
  in the input stream that matched the syntax definition.

  <p>All syntax tree traversal actions are performed by calling SYN
  library routines with names SYN_TRAV_xxx.

  <h3>Traversal overview</h3><indent>

    <p>The SYN library maintains a current position within the syntax
    tree.  The application traverses the tree by advancing to the next
    entry.  If that entry is a subordinate level, then the application can
    go down into the subordinate level.  The application can pop back to
    the parent level at any time, although this is usually done with the
    end of the subordinate level is encountered.

    <p>Named syntax constructions in the syntax definition result in
    subordinate syntax tree entries.  Tagged items in the syntax
    definition result in "tag" entries in the current level.  Applications
    can determine and retrieve the input stream characters that were
    tagged.  Acting upon tagged entries is how the application implements
    whatever semantics were specified by the input stream.

    </p></indent>

  <h3>Initializing</h3><indent>

    <p>After a parse, the syntax tree traversal state must be initialized
    before the tree can be traversed.  This is done with:

</p><indent><p><pre>
procedure syn_trav_init (              {init traversion, at start, stack empty}
  in out  syn: syn_t);                 {SYN library use state}
  val_param; extern;
</pre></p></indent>

    <p>This sets the current traversal position to the start of the tree,
    which is the start of the top level.  The current entry will be the
    start of the top tree level.

    <p>The syntax tree position stack is also initialized to empty.  The
    position stack is discussed in more detail in the section
    <i>Saving/restoring tree position</i>, below.

    </p></indent>

  <h3>Getting entries</h3><indent>

    <p>There are two types of values used to indicate what an entry is.
    These are a <tt>syn_tent_k_t</tt> enumerated value, and an ordinary
    integer.

    <p>The enumerated value is useful for determining the overall type of
    a syntax tree entry, while maintaining strong type checking.  The
    possible values are:</p><indent><dl>

      <dt><tt>syn_tent_lev_k</tt><dd>

        <p>First entry of a syntax tree level.  All syntax tree levels
        start with this entry.

      <dt><tt>syn_tent_end_k</tt><dd>

        <p>Last entry of a syntax tree level.  There is no "next" entry
        here. Attempts to get subsequent entries at this level result in
        staying at this END entry.

      <dt><tt>syn_tent_sub_k</tt><dd>

        <p>A subordinate level exists below this entry.

      <dt><tt>syn_tent_tag_k</tt><dd>

        <p>Result of a tag in the syntax definition.

      <dt><tt>syn_tent_err_k</tt><dd>

        <p>The farthest point reached in the input stream during an error
        re-parse.  There is no "next" entry.

      </dl></p></indent>

    <p>The integer value is the only way to get the ID of a tag in the
    syntax definition.  Tag IDs are always integers of 1 or greater.
    Non-tag tree entries are indicates with 0 or less.  These are one of
    the constants SYN_TAG_xxx_K.

    <p>The current entry can be determined by calling one of

</p><indent><p><pre>
function syn_trav_type (               {get type of current syntax tree entry}
  in out  syn: syn_t)                  {SYN library use state}
  :syn_tent_k_t;                       {syntax tree entry type ID}
  val_param; extern;

function syn_trav_tag (                {get ID of current tag entry}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {1-N tag number or SYN_TAG_xxx_K}
  val_param; extern;
</pre></p></indent>

    <p>The first gets the enumerated entry type ID, and the second the
    integer entry ID value.

    <p>To advance to the next sequential entry in the current tree level,
    call one of:

</p><indent><p><pre>
function syn_trav_next (               {to next syntax tree entry}
  in out  syn: syn_t)                  {SYN library use state}
  :syn_tent_k_t;                       {type of syntax tree entry found}
  val_param; extern;

function syn_trav_next_tag (           {to next entry, return its tag value}
  in out  syn: syn_t)                  {SYN library use state}
  :sys_int_machine_t;                  {1-N tag number or SYN_TAG_xxx_K}
  val_param; extern;
</pre></p></indent>

    <p>As before, the first returns the entry type ID of the new entry,
    and the second its integer ID value.

    <p>Two functions can be used to go down into a subordinate syntax tree
    level:

</p><indent><p><pre>
function syn_trav_down (               {down into subordinate level from curr entry}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {successfully entered subordinate level}
  val_param; extern;

function syn_trav_next_down (          {into sub level of next entry}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {next was sub level, moved down}
  val_param; extern;
</pre></p></indent>

    <p>The first goes down from the current entry.  The second first
    advances to the next entry in the current level, then attempts to go
    down into a subordinate level from there.  In either case, the
    function returns TRUE if the tree position is now one level lower than
    when the call was made.  FALSE indicates that the entry attempting to
    go down from was not a subordinate level entry.

    <p>To go back up from a subordinate level to the parent level, use:

</p><indent><p><pre>
function syn_trav_up (                 {pop up to parent syntax tree level}
  in out  syn: syn_t)                  {SYN library use state}
  :boolean;                            {successfully popped to parent level}
  val_param; extern;
</pre></p></indent>

    <p>When successful (there was a parent level), the current entry is
    the one immediately after the subordinate level entry in the parent.

    </p></indent>

  <h3>Getting input stream text</h3><indent>

    </p></indent>

  <h3>Saving/restoring tree position</h3><indent>

    </p></indent>

  <h3>Current tree state</h3><indent>

    </p></indent>

  </p></indent>


<!-- -------------------------------------------------------------------------->
<h1 id="syncalc">SYNCALC Example Application</h1>


<!-- -------------------------------------------------------------------------->
<h1 id="testsyn_cust">Modifying TEST_SYN for custom syntax</h1>


<!-- -------------------------------------------------------------------------->
<h1 id="cust_constr">Manually creating syntax parsing routine</h1>


</body></html>

</p><indent><p><pre>
</pre></p></indent>
